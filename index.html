<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport d'audience - Taskalys</title>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Biblioth√®ques pour traitement local -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            background-color: #2c2c83;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 20px;
        }

        .container {
            padding: 40px;
            max-width: 700px;
            width: 100%;
        }

        .logo {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo img {
            height: 60px;
            width: auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 1px;
            white-space: nowrap;
            font-family: 'Poppins', sans-serif;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1.1rem;
            font-family: 'Poppins', sans-serif;
        }

        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-align: left;
        }

        input[type="text"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        input[type="text"]::placeholder, input[type="password"]::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .password-toggle {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .password-toggle svg {
            width: 20px;
            height: 20px;
            fill: white;
            transition: fill 0.3s ease;
        }

        .password-toggle:hover svg {
            fill: rgba(255, 255, 255, 0.8);
        }

        .password-input-wrapper {
            position: relative;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 15px;
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-height: 80px;
        }

        .file-input-label:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        .file-input-label.has-file {
            border-color: rgba(76, 175, 80, 0.6);
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
        }

        .excel-input-label {
            border-color: rgba(34, 139, 34, 0.5);
            background: rgba(34, 139, 34, 0.1);
        }

        .excel-input-label:hover {
            border-color: rgba(34, 139, 34, 0.8);
            background: rgba(34, 139, 34, 0.2);
        }

        .excel-input-label.has-file {
            border-color: #22B022;
            background: rgba(34, 176, 34, 0.2);
            color: #22B022;
        }

        .powerpoint-input-label {
            border-color: rgba(255, 87, 34, 0.5);
            background: rgba(255, 87, 34, 0.1);
        }

        .powerpoint-input-label:hover {
            border-color: rgba(255, 87, 34, 0.8);
            background: rgba(255, 87, 34, 0.2);
        }

        .powerpoint-input-label.has-file {
            border-color: #FF5722;
            background: rgba(255, 87, 34, 0.2);
            color: #FF5722;
        }

        .submit-btn {
            width: 100%;
            padding: 18px;
            background: #a2137b;
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .submit-btn:hover {
            background: #8a0f66;
            transform: translateY(-2px);
        }

        .submit-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .doc-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 0.9rem;
            text-decoration: underline;
            margin-top: 15px;
            padding: 0;
            transition: color 0.3s ease;
        }

        .doc-btn:hover {
            color: rgba(255, 255, 255, 1);
        }

        .loading-screen {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading-screen.active {
            display: block;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.3rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .time-estimation {
            margin-top: 20px;
            text-align: center;
            color: white;
        }

        .estimation-text {
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .time-value {
            font-weight: 600;
            color: #a2137b;
            font-size: 1.1rem;
        }

        .progress-info {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        .dots {
            display: inline-block;
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        .ppt-loading-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #2c2c83;
            z-index: 99999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: 'Poppins', sans-serif;
            text-align: center;
        }

        .ppt-loading-screen.active {
            display: flex;
        }

        .ppt-loading-logo {
            width: 120px;
            height: 120px;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        .ppt-loading-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
        }

        .ppt-loading-subtitle {
            font-size: 1.2rem;
            margin-bottom: 60px;
            text-align: center;
            opacity: 0.8;
        }

        .progress-container {
            width: 80%;
            max-width: 600px;
            height: 16px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            margin: 30px 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #a2137b, #ff6b9d, #ff9ec7, #a2137b);
            background-size: 300% 100%;
            border-radius: 8px;
            width: 0%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            animation: gradientMove 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(162, 19, 123, 0.5);
        }

        @keyframes gradientMove {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 1.1rem;
            text-align: center;
            opacity: 0.9;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .ppt-status {
            font-size: 1rem;
            text-align: center;
            margin-top: 20px;
            opacity: 0.8;
            min-height: 25px;
            max-width: 80%;
            line-height: 1.4;
        }

        .warning-message {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            padding: 15px 20px;
            margin-top: 30px;
            font-size: 0.95rem;
            color: #ffc107;
            max-width: 500px;
            line-height: 1.5;
        }

        .warning-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 1.1rem;
        }

        .powered-by {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .powered-by a {
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
        }

        .powered-by a:hover {
            text-decoration: underline;
        }

        .form-container {
            transition: opacity 0.3s ease;
        }

        .form-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logs-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(44, 44, 131, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            max-height: 300px;
            z-index: 1000;
            transition: transform 0.3s ease;
            display: none; /* Masquer la console par d√©faut */
        }

        .logs-container.collapsed {
            transform: translateY(calc(100% - 40px));
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }

        .logs-header h3 {
            color: white;
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
        }

        .clear-logs-btn {
            background: #a2137b;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .clear-logs-btn:hover {
            background: #8a0f66;
        }

        .logs-content {
            max-height: 250px;
            overflow-y: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-time {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            min-width: 80px;
        }

        .log-message {
            color: white;
            flex: 1;
        }

        .log-entry.info .log-message {
            color: #4CAF50;
        }

        .log-entry.warning .log-message {
            color: #FF9800;
        }

        .log-entry.error .log-message {
            color: #FF5722;
        }

        .log-entry.success .log-message {
            color: #4CAF50;
            font-weight: 600;
        }

        /* Styles pour l'√©diteur d'email simplifi√© */
        .email-editor-simple {
            margin-top: 10px;
        }


        #emailTemplateEditor {
            width: 100%;
            min-height: 150px;
            max-height: 400px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.95rem;
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            resize: vertical;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        #emailTemplateEditor:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        #emailTemplateEditor::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Style de la scrollbar pour le textarea */
        #emailTemplateEditor::-webkit-scrollbar {
            width: 6px;
        }

        #emailTemplateEditor::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #emailTemplateEditor::-webkit-scrollbar-thumb {
            background: rgba(162, 19, 123, 0.6);
            border-radius: 3px;
        }

        #emailTemplateEditor::-webkit-scrollbar-thumb:hover {
            background: rgba(162, 19, 123, 0.8);
        }




        /* Styles pour le champ email */
        input[type="email"] {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-align: left;
        }

        input[type="email"]:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        input[type="email"]::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        @media (max-width: 600px) {
            .container {
                padding: 30px 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .logo img {
                height: 50px;
            }

            .logs-container {
                max-height: 200px;
            }

            .logs-content {
                max-height: 150px;
                font-size: 0.8rem;
            }

            .email-editor-container {
                flex-direction: column;
                gap: 15px;
            }

            .variables-panel {
                flex: none;
            }

            .variable-blocks {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .variable-block {
                flex: 1;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="assets/logo_buster.svg" alt="Buster Logo">
        </div>

        <h1>Rapport d'audience</h1>

        <div class="form-container" id="formContainer">
            <form id="uploadForm">
                <div class="form-group">
                    <label for="excelFile">Fichier Excel</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="excelFile" name="excelFile" class="file-input" accept=".xlsx,.xls" required>
                        <label for="excelFile" class="file-input-label excel-input-label" id="excelLabel">
                            <img src="assets/logo_excel.svg" alt="Excel" style="width: 48px; height: 48px;">
                            <span>S√©lectionner un fichier Excel (.xlsx, .xls)</span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="powerpointFile">Fichier PowerPoint</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="powerpointFile" name="powerpointFile" class="file-input" accept=".pptx,.ppt" required>
                        <label for="powerpointFile" class="file-input-label powerpoint-input-label" id="powerpointLabel">
                            <img src="assets/logo_powerpoint.svg" alt="PowerPoint" style="width: 48px; height: 48px;">
                            <span>S√©lectionner un fichier PowerPoint (.pptx, .ppt)</span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="emailInput">Email de destination</label>
                    <input type="email" id="emailInput" name="emailInput" placeholder="votre@email.com" required>
                </div>


                <div class="form-group">
                    <label for="emailTemplateEditor">Template Email</label>
                    <div class="email-editor-simple">
                        <textarea id="emailTemplateEditor" name="emailTemplateEditor" placeholder="Tapez votre template email ici...">Bonjour,
Vous trouverez ci-joint le bilan complet de votre campagne men√©e sur les bus de {VILLE} {PERIODE}.
Durant cette p√©riode (semaine {WEEK}), vous avez touch√© une audience de {AUDIENCE} personnes et votre campagne a g√©n√©r√© plus de {ODV} contacts.
Parcourez le document en pi√®ce jointe pour conna√Ætre les indicateurs cl√©s de votre campagne et le profil de votre audience.
Bien √† vous,</textarea>
                    </div>
                </div>


                <button type="submit" class="submit-btn" id="submitBtn">
                    G√©n√©rer
                </button>
            </form>

            
            <div style="text-align: center; margin-top: 20px;">
                <button type="button" class="doc-btn" id="docBtn">
                    Documentation
                </button>
            </div>
        </div>

        <div class="loading-screen" id="loadingScreen">
            <div class="spinner"></div>
            <div class="loading-text">
                Traitement en cours<span class="dots"></span><br>
                G√©n√©ration des rapports d'audience
            </div>
            <div class="time-estimation">
                <div class="estimation-text">
                    <span id="timeRemainingText">Estimation du temps restant :</span>
                    <span id="timeRemainingValue" class="time-value">Calcul en cours...</span>
                </div>
                <div class="progress-info">
                    <span id="processedCount">0</span> / <span id="totalCount">0</span> fichiers trait√©s
                </div>
            </div>
        </div>

        <div class="ppt-loading-screen" id="pptLoadingScreen">
            <img src="assets/logo_buster.svg" alt="Logo" class="ppt-loading-logo">
            <div class="ppt-loading-title">Traitement en cours</div>
            <div class="ppt-loading-subtitle">G√©n√©ration des rapports d'audience...</div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="progress-text" id="progressText">0/0 fichiers trait√©s</div>
            <div class="ppt-status" id="pptStatus">Initialisation...</div>
            
            <div class="warning-message">
                <span class="warning-icon">‚ö†Ô∏è</span>
                <strong>Ne fermez pas cette page</strong><br>
                Le traitement est en cours. Les rapports seront envoy√©s par email.
            </div>
        </div>

        <div class="powered-by">
            Powered by <a href="https://taskalys.fr" target="_blank">Taskalys.fr</a>
            <button id="toggleConsoleBtn" style="margin-left: 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem;">Console</button>
        </div>
    </div>

    <div class="logs-container" id="logsContainer">
        <div class="logs-header">
            <h3>Console</h3>
            <button id="clearLogsBtn" class="clear-logs-btn">Effacer</button>
        </div>
        <div class="logs-content" id="logsContent">
            <div class="log-entry info">
                <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                <span class="log-message">Interface pr√™te - En attente de fichiers</span>
            </div>
        </div>
    </div>

    <script>
        // Fonction pour traiter les graphiques via XML uniquement (sans Excel)
        async function processEmbeddedCharts(zip, templateData, row = null, excelData = null) {
            try {
                addLog('üìä RECHERCHE DES GRAPHIQUES VIA XML UNIQUEMENT', 'info');
                
                let graphiquesTrouves = 0;
                
                // 1. Chercher les fichiers XML des graphiques
                addLog('üìä RECHERCHE DES FICHIERS XML DE GRAPHIQUES...', 'info');
                const chartXmlFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('charts/chart') && relativePath.endsWith('.xml')) {
                        chartXmlFiles.push(relativePath);
                    }
                });
                
                // DEBUG: Recherche globale et exhaustive de GRAPH_PROV
                addLog('üîç DEBUG: Recherche globale et exhaustive de GRAPH_PROV...', 'info');
                let globalFound = false;
                let allFiles = [];
                
                // Collecter tous les fichiers (XML, Excel, etc.)
                zip.forEach((relativePath, file) => {
                    allFiles.push({ path: relativePath, file: file });
                });
                
                addLog(`üìã Analyse de ${allFiles.length} fichiers au total`, 'info');
                
                // Analyser chaque fichier
                for (const fileInfo of allFiles) {
                    try {
                        const { path, file } = fileInfo;
                        
                        // Pour les fichiers XML
                        if (path.endsWith('.xml')) {
                            const content = await file.async('string');
                            
                            // Recherche exacte
                            if (content.includes('GRAPH_PROV')) {
                                addLog(`  ‚úÖ GRAPH_PROV trouv√© dans: ${path}`, 'success');
                                globalFound = true;
                            }
                            // Recherche avec variations
                            else if (content.includes('GRAPHIQUE PROVENANCE')) {
                                addLog(`  üîç "GRAPHIQUE PROVENANCE" (avec espace) trouv√© dans: ${path}`, 'warning');
                            }
                            else if (content.includes('graph_prov')) {
                                addLog(`  üîç "graph_prov" (minuscules) trouv√© dans: ${path}`, 'warning');
                            }
                            else if (content.includes('GraphProv')) {
                                addLog(`  üîç "GraphProv" (camelCase) trouv√© dans: ${path}`, 'warning');
                            }
                            // Recherche de patterns similaires
                            else if (content.includes('PROVENANCE')) {
                                addLog(`  üîç Mot "PROVENANCE" trouv√© dans: ${path}`, 'info');
                                // Extraire le contexte autour de PROVENANCE
                                const provenanceIndex = content.indexOf('PROVENANCE');
                                const context = content.substring(Math.max(0, provenanceIndex - 50), provenanceIndex + 50);
                                addLog(`    üìÑ Contexte: ...${context}...`, 'info');
                            }
                        }
                        
                        // Pour les fichiers Excel embarqu√©s
                        else if (path.includes('embeddings/') && path.endsWith('.xlsx')) {
                            addLog(`  üìä Analyse du fichier Excel embarqu√©: ${path}`, 'info');
                            try {
                                const excelBuffer = await file.async('arraybuffer');
                                const workbook = XLSX.read(excelBuffer, { type: 'array' });
                                
                                // Chercher dans toutes les feuilles
                                for (const sheetName of Object.keys(workbook.Sheets)) {
                                    const sheet = workbook.Sheets[sheetName];
                                    const sheetContent = XLSX.utils.sheet_to_txt(sheet);
                                    
                                    if (sheetContent.includes('GRAPH_PROV')) {
                                        addLog(`    ‚úÖ GRAPH_PROV trouv√© dans ${path}, feuille "${sheetName}"`, 'success');
                                        globalFound = true;
                                    }
                                    else if (sheetContent.includes('GRAPHIQUE PROVENANCE')) {
                                        addLog(`    üîç "GRAPHIQUE PROVENANCE" trouv√© dans ${path}, feuille "${sheetName}"`, 'warning');
                                    }
                                    else if (sheetContent.includes('PROVENANCE')) {
                                        addLog(`    üîç "PROVENANCE" trouv√© dans ${path}, feuille "${sheetName}"`, 'info');
                                    }
                                }
                            } catch (excelError) {
                                addLog(`    ‚ö†Ô∏è Erreur lecture Excel ${path}: ${excelError.message}`, 'warning');
                            }
                        }
                        
                    } catch (error) {
                        addLog(`  ‚ö†Ô∏è Erreur analyse ${fileInfo.path}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`üìã ${chartXmlFiles.length} fichiers XML de graphiques trouv√©s`, 'info');
                
                // Traiter chaque fichier XML de graphique
                for (const chartXmlFile of chartXmlFiles) {
                    try {
                        addLog(`  üìä Traitement du graphique XML: ${chartXmlFile}`, 'info');
                        const chartContent = await zip.file(chartXmlFile).async('string');
                        
                        // Modifier le contenu XML du graphique
                        const modifiedContent = await processChartXmlContent(chartContent, templateData, row, excelData);
                        
                        if (modifiedContent !== chartContent) {
                            zip.file(chartXmlFile, modifiedContent);
                            addLog(`    ‚úÖ Graphique XML modifi√©: ${chartXmlFile}`, 'success');
                            graphiquesTrouves++;
                        }
                        
                    } catch (error) {
                        addLog(`  ‚ö†Ô∏è Erreur traitement ${chartXmlFile}: ${error.message}`, 'warning');
                    }
                }
                
                // 2. Toujours chercher dans les slides pour GRAPH_PROV
                addLog('üìä Recherche dans les slides pour GRAPH_PROV...', 'info');
                const slideGraphiques = await processChartsInSlides(zip, templateData, row, excelData);
                graphiquesTrouves += slideGraphiques;

                return graphiquesTrouves;

            } catch (error) {
                addLog(`‚ùå Erreur traitement graphiques XML: ${error.message}`, 'error');
                return 0;
            }
        }

        // Fonction pour traiter les donn√©es GRAPH_PROV selon l'algorithme sp√©cifique
        async function processGraphProvData(row, excelData) {
            try {
                addLog(`    üèòÔ∏è ALGORITHME GRAPH_PROV: D√©marrage`, 'info');
                
                // 1. Aller dans la sheet Provenance
                const provenanceSheet = excelData.Sheets['Provenance'];
                if (!provenanceSheet) {
                    addLog(`    ‚ùå Sheet "Provenance" non trouv√©e`, 'error');
                    return null;
                }
                addLog(`    ‚úÖ Sheet "Provenance" trouv√©e`, 'success');
                
                // 2. R√©cup√©rer la ville depuis les donn√©es du r√©seau
                const networkName = row['r√©seau'] || row['R√©seau'] || '';
                const networkData = parseNetworkData(networkName);
                const city = networkData.ville || row['Ville'] || '';
                
                if (!city) {
                    addLog(`    ‚ùå Ville non trouv√©e dans les donn√©es`, 'error');
                    return null;
                }
                
                const cityLower = city.toLowerCase();
                addLog(`    üèôÔ∏è Ville recherch√©e: "${city}" (${cityLower})`, 'info');
                
                // 3. Aller colonne B et descendre tant que la case n'est pas √©gale √† la ville
                let cityRowIndex = -1;
                for (let rowIndex = 2; rowIndex <= 100; rowIndex++) {
                    const cellB = provenanceSheet[`B${rowIndex}`];
                    if (cellB && cellB.v) {
                        const cellValue = cellB.v.toString().toLowerCase();
                        if (cellValue === cityLower) {
                            cityRowIndex = rowIndex;
                            addLog(`    ‚úÖ Ville trouv√©e √† la ligne ${rowIndex}`, 'success');
                            break;
                        }
                    }
                }
                
                if (cityRowIndex === -1) {
                    addLog(`    ‚ùå Ville "${city}" non trouv√©e dans la colonne B`, 'error');
                    return null;
                }
                
                // 4. Remonter d'une ligne et lire les l√©gendes (colonnes C √† H)
                const legendRowIndex = cityRowIndex - 1;
                const legendColumns = ['C', 'D', 'E', 'F', 'G', 'H'];
                const legends = [];
                
                addLog(`    üìã Lecture des l√©gendes (ligne ${legendRowIndex}, colonnes C √† H):`, 'info');
                for (let i = 0; i < legendColumns.length; i++) {
                    const cellRef = `${legendColumns[i]}${legendRowIndex}`;
                    const cell = provenanceSheet[cellRef];
                    if (cell && cell.v) {
                        legends.push(cell.v.toString());
                        addLog(`      ${legendColumns[i]}${legendRowIndex}: "${cell.v}"`, 'info');
                    } else {
                        legends.push(`Ville ${i + 1}`);
                        addLog(`      ${cellRef}: vide, nom par d√©faut`, 'warning');
                    }
                }
                
                // 5. Trouver la ligne des valeurs avec la date et la ville
                const currentPeriod = row['P√©riode'] || '';
                let dataRowIndex = -1;
                
                addLog(`    üîç Recherche de la ligne de donn√©es (P√©riode: "${currentPeriod}", Ville: "${city}")`, 'info');
                for (let rowIndex = 2; rowIndex <= 100; rowIndex++) {
                    const cellA = provenanceSheet[`A${rowIndex}`];
                    const cellB = provenanceSheet[`B${rowIndex}`];
                    
                    if (cellA && cellB && cellA.v && cellB.v) {
                        const dateValue = cellA.v.toString();
                        const villeValue = cellB.v.toString().toLowerCase();
                        
                        if (dateValue.includes(currentPeriod) && villeValue === cityLower) {
                            dataRowIndex = rowIndex;
                            addLog(`    ‚úÖ Ligne de donn√©es trouv√©e: ${rowIndex} (Date: "${dateValue}", Ville: "${villeValue}")`, 'success');
                            break;
                        }
                    }
                }
                
                if (dataRowIndex === -1) {
                    addLog(`    ‚ùå Ligne de donn√©es non trouv√©e pour la p√©riode "${currentPeriod}" et ville "${city}"`, 'error');
                    return null;
                }
                
                // 6. R√©cup√©rer les valeurs (colonnes C √† H) et les associer aux l√©gendes
                const values = [];
                let totalPercentage = 0;
                
                addLog(`    üìä Lecture des valeurs (ligne ${dataRowIndex}, colonnes C √† H):`, 'info');
                for (let i = 0; i < legendColumns.length; i++) {
                    const cellRef = `${legendColumns[i]}${dataRowIndex}`;
                    const cell = provenanceSheet[cellRef];
                    if (cell && cell.v !== undefined) {
                        const value = parseFloat(cell.v);
                        const percentage = (value * 100).toFixed(1);
                        values.push({
                            name: legends[i],
                            value: value,
                            percentage: parseFloat(percentage)
                        });
                        totalPercentage += parseFloat(percentage);
                        addLog(`      ${cellRef}: ${legends[i]} = ${percentage}%`, 'info');
                    } else {
                        addLog(`      ${cellRef}: vide`, 'warning');
                    }
                }
                
                // 7. Ajouter la cat√©gorie "Autres" pour arriver √† 100%
                const othersPercentage = Math.max(0, 100 - totalPercentage);
                if (othersPercentage > 0) {
                    values.push({
                        name: 'Autres',
                        value: othersPercentage / 100,
                        percentage: othersPercentage
                    });
                    addLog(`    üìä Autres: ${othersPercentage.toFixed(1)}% (pour arriver √† 100%)`, 'info');
                }
                
                // 8. Construire la cha√Æne de donn√©es pour le graphique
                const graphProvData = values.map(v => `${v.name}: ${v.percentage.toFixed(1)}%`).join(', ');
                addLog(`    ‚úÖ Donn√©es GRAPH_PROV finales: "${graphProvData}"`, 'success');
                
                return graphProvData;
                
            } catch (error) {
                addLog(`    ‚ùå Erreur traitement GRAPH_PROV: ${error.message}`, 'error');
                return null;
            }
        }

        // Fonction pour traiter le contenu XML des graphiques
        async function processChartXmlContent(chartContent, templateData, row = null, excelData = null) {
            try {
                addLog(`    üîÑ TRAITEMENT XML DU GRAPHIQUE`, 'info');
                
                // DEBUG: Analyser le contenu XML pour comprendre la structure
                addLog(`    üîç ANALYSE DU CONTENU XML...`, 'info');
                
                // Chercher les balises XML importantes
                const hasValTags = chartContent.includes('<c:val>');
                const hasVTags = chartContent.includes('<c:v>');
                const hasPtTags = chartContent.includes('<c:pt');
                const hasCellTags = chartContent.includes('<c:cell>');
                
                addLog(`    üìã Structure XML d√©tect√©e:`, 'info');
                addLog(`      - <c:val>: ${hasValTags ? '‚úÖ' : '‚ùå'}`, 'info');
                addLog(`      - <c:v>: ${hasVTags ? '‚úÖ' : '‚ùå'}`, 'info');
                addLog(`      - <c:pt>: ${hasPtTags ? '‚úÖ' : '‚ùå'}`, 'info');
                addLog(`      - <c:cell>: ${hasCellTags ? '‚úÖ' : '‚ùå'}`, 'info');
                
                // Afficher un √©chantillon du contenu XML
                const sampleLength = Math.min(500, chartContent.length);
                const xmlSample = chartContent.substring(0, sampleLength);
                addLog(`    üìÑ √âchantillon XML (${sampleLength} caract√®res):`, 'info');
                addLog(`      ${xmlSample.replace(/\n/g, ' ').substring(0, 200)}...`, 'info');
                
                let modifiedContent = chartContent;
                
                // DEBUG: V√©rifier si GRAPH_PROV est pr√©sent dans le XML
                addLog(`    üîç DEBUG: Analyse d√©taill√©e du contenu XML...`, 'info');
                
                // Recherche exacte
                if (modifiedContent.includes('GRAPH_PROV')) {
                    addLog(`    ‚úÖ GRAPH_PROV trouv√© exactement!`, 'success');
                    addLog(`    üèòÔ∏è TRAITEMENT GRAPH_PROV: Algorithme complet Provenance`, 'info');
                    const graphProvData = await processGraphProvData(row, excelData);
                    if (graphProvData) {
                        modifiedContent = await updateChartXmlData(modifiedContent, 'GRAPH_PROV', graphProvData);
                    }
                } else {
                    addLog(`    ‚ùå GRAPH_PROV non trouv√© exactement`, 'warning');
                    
                    // Recherche avec variations
                    if (modifiedContent.includes('GRAPHIQUE PROVENANCE')) {
                        addLog(`    üîç "GRAPHIQUE PROVENANCE" (avec espace) trouv√©!`, 'warning');
                    }
                    if (modifiedContent.includes('GRAPH_PROV')) {
                        addLog(`    üîç "GRAPH_PROV" (minuscules) trouv√©!`, 'warning');
                    }
                    if (modifiedContent.includes('GRAPH_PROV')) {
                        addLog(`    üîç "GRAPH_PROV" (camelCase) trouv√©!`, 'warning');
                    }
                    if (modifiedContent.includes('PROVENANCE')) {
                        addLog(`    üîç Mot "PROVENANCE" trouv√©!`, 'info');
                        // Extraire le contexte
                        const provenanceIndex = modifiedContent.indexOf('PROVENANCE');
                        const context = modifiedContent.substring(Math.max(0, provenanceIndex - 100), provenanceIndex + 100);
                        addLog(`    üìÑ Contexte PROVENANCE: ...${context.replace(/\n/g, ' ')}...`, 'info');
                    }
                    
                    // Recherche plus flexible avec regex
                    const provenanceRegex = /graphique[\s\-_]?provenance/gi;
                    const provenanceMatches = modifiedContent.match(provenanceRegex);
                    if (provenanceMatches) {
                        addLog(`    üîç Patterns "graphique*provenance" trouv√©s: ${provenanceMatches.join(', ')}`, 'warning');
                    }
                    
                    // Recherche de tous les mots contenant "provenance"
                    const allProvenanceRegex = /\w*provenance\w*/gi;
                    const allMatches = modifiedContent.match(allProvenanceRegex);
                    if (allMatches) {
                        addLog(`    üîç Tous les mots contenant "provenance": ${allMatches.join(', ')}`, 'info');
                    }
                    
                    // DEBUG: V√©rifier quels identifiants sont pr√©sents
                    if (modifiedContent.includes('GRAPH_AGE')) addLog(`    ‚úÖ DEBUG: GRAPH_AGE trouv√©`, 'success');
                    if (modifiedContent.includes('GRAPH_CSP')) addLog(`    ‚úÖ DEBUG: GRAPH_CSP trouv√©`, 'success');
                    if (modifiedContent.includes('GRAPH_SEXE')) addLog(`    ‚úÖ DEBUG: GRAPH_SEXE trouv√©`, 'success');
                    
                    // DEBUG: Afficher un √©chantillon du XML pour voir ce qui est pr√©sent
                    const xmlSample = modifiedContent.substring(0, 1000);
                    addLog(`    üìÑ √âchantillon XML (1000 caract√®res): ${xmlSample.replace(/\n/g, ' ')}`, 'info');
                }
                
                // Chercher et remplacer les donn√©es AGE dans le XML
                if (templateData['AGE']) {
                    addLog(`    üìä Traitement des donn√©es AGE: "${templateData['AGE']}"`, 'info');
                    modifiedContent = await updateChartXmlData(modifiedContent, 'AGE', templateData['AGE']);
                }
                
                // Chercher et remplacer les donn√©es CSP dans le XML (SEULEMENT si ce n'est pas GRAPH_PROV)
                if (templateData['SOCIO-PRO'] && !modifiedContent.includes('GRAPH_PROV')) {
                    addLog(`    üìä Traitement des donn√©es CSP: "${templateData['SOCIO-PRO']}"`, 'info');
                    modifiedContent = await updateChartXmlData(modifiedContent, 'CSP', templateData['SOCIO-PRO']);
                } else if (templateData['SOCIO-PRO'] && modifiedContent.includes('GRAPH_PROV')) {
                    addLog(`    üö´ CSP ignor√© pour GRAPH_PROV - Utilisation des donn√©es de provenance uniquement`, 'warning');
                }
                
                // Chercher et remplacer les donn√©es SEXE dans le XML
                if (templateData['SEXE']) {
                    addLog(`    üìä Traitement des donn√©es SEXE: "${templateData['SEXE']}"`, 'info');
                    modifiedContent = await updateChartXmlData(modifiedContent, 'SEXE', templateData['SEXE']);
                }
                
                addLog(`    ‚úÖ XML du graphique trait√©`, 'success');
                return modifiedContent;
                
            } catch (error) {
                addLog(`    ‚ùå Erreur traitement XML: ${error.message}`, 'error');
                return chartContent;
            }
        }

        // Fonction pour mettre √† jour les donn√©es dans le XML des graphiques (avec s√©paration par type)
        async function updateChartXmlData(xmlContent, chartType, dataString) {
            try {
                addLog(`      üîÑ MISE √Ä JOUR XML ${chartType}`, 'info');
                
                // Parser les donn√©es selon le type
                let values = [];
                if (chartType === 'AGE') {
                    // NOUVEAU PATTERN: G√©rer les tranches d'√¢ge ET "65 ans ou plus"
                    const agePattern = /(\d+(?:-\d+)?\s*ans(?:\s+ou\s+plus)?):\s*([\d.]+)%/g;
                    const ageMatches = [...dataString.matchAll(agePattern)];
                    values = ageMatches.map(match => parseFloat(match[2]) / 100);
                    
                    // DEBUG: Afficher les matches trouv√©s
                    addLog(`      üîç Matches AGE trouv√©s: ${ageMatches.length}`, 'info');
                    ageMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" ‚Üí ${match[2]}%`, 'info');
                    });
                } else if (chartType === 'CSP') {
                    // CORRECTION: Regex am√©lior√© pour √©viter les virgules
                    const cspPattern = /([^:,]+):\s*([\d.]+)%/g;
                    const cspMatches = [...dataString.matchAll(cspPattern)];
                    
                    // NOUVELLE APPROCHE: R√©organiser les donn√©es selon l'ordre du graphique PowerPoint
                    const cspOrderMapping = {
                        'Cadres': 'Cadres et professions intellectuelles sup.',
                        'Professions interm√©diaires': 'Professions interm√©diaires',
                        'Artisans': 'Artisans, commer√ßants et chefs d\'entreprise',
                        'Employ√©s': 'Employ√©s',
                        'Ouvriers': 'Ouvriers',
                        'Agriculteurs': 'Agriculteurs exploitants',
                        '√âtudiants': 'El√®ves, √©tudiants, stagiaires',
                        'Retrait√©s': 'Retrait√©s',
                        'Autres': 'Autres personnes sans activit√© pro.'
                    };
                    
                    // Ordre attendu dans le graphique PowerPoint (selon l'image)
                    const expectedOrder = [
                        'Cadres et professions intellectuelles sup.',      // Position 1 - CSP+
                        'Professions interm√©diaires',                      // Position 2 - CSP+
                        'Artisans, commer√ßants et chefs d\'entreprise',    // Position 3 - CSP+
                        'Employ√©s',                                        // Position 4 - CSP-
                        'Ouvriers',                                        // Position 5 - CSP-
                        'Agriculteurs exploitants',                        // Position 6 - CSP-
                        'El√®ves, √©tudiants, stagiaires',                   // Position 7 - CSP-
                        'Retrait√©s',                                       // Position 8 - CSP-
                        'Autres personnes sans activit√© pro.'              // Position 9 - CSP-
                    ];
                    
                    addLog(`      üìã Ordre attendu dans PowerPoint:`, 'info');
                    expectedOrder.forEach((label, index) => {
                        const section = index < 3 ? 'CSP+' : 'CSP-';
                        addLog(`        ${index + 1}. [${section}] ${label}`, 'info');
                    });
                    
                    // Cr√©er un mapping des donn√©es saisies
                    const dataMap = {};
                    cspMatches.forEach(match => {
                        // NETTOYAGE: Supprimer les virgules et espaces en d√©but/fin
                        const label = match[1].replace(/^[,\s]+|[,\s]+$/g, '').trim();
                        const value = parseFloat(match[2]) / 100;
                        dataMap[label] = value;
                        addLog(`        üßπ Label nettoy√©: "${match[1]}" ‚Üí "${label}"`, 'info');
                    });
                    
                    // R√©organiser selon l'ordre attendu
                    values = expectedOrder.map((expectedLabel, index) => {
                        // Chercher la correspondance dans les donn√©es saisies
                        for (const [inputLabel, value] of Object.entries(dataMap)) {
                            if (cspOrderMapping[inputLabel] === expectedLabel) {
                                addLog(`        üîó Mapping ${index + 1}: "${inputLabel}" ‚Üí "${expectedLabel}" = ${(value * 100).toFixed(1)}%`, 'info');
                                return value;
                            }
                        }
                        addLog(`        ‚ùå Pas de correspondance trouv√©e pour "${expectedLabel}"`, 'warning');
                        return 0; // Valeur par d√©faut si pas trouv√©
                    });
                    
                    // DEBUG: Afficher les correspondances CSP
                    addLog(`      üîç Correspondances CSP trouv√©es: ${cspMatches.length}`, 'info');
                    cspMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" ‚Üí ${match[2]}%`, 'info');
                    });
                    
                    addLog(`      üîÑ R√©organisation selon l'ordre du graphique:`, 'info');
                    expectedOrder.forEach((label, index) => {
                        addLog(`        ${index + 1}. ${label}: ${(values[index] * 100).toFixed(1)}%`, 'info');
                    });
                    
                    // DEBUG SP√âCIFIQUE: Analyser la premi√®re valeur (Cadres)
                    if (values.length > 0) {
                        addLog(`      üîç ANALYSE PREMI√àRE VALEUR (Cadres):`, 'info');
                        addLog(`        Valeur actuelle: ${(values[0] * 100).toFixed(1)}%`, 'info');
                        addLog(`        Position: 1/9`, 'info');
                        
                        // V√©rifier si la premi√®re valeur est anormale
                        if (values[0] > 0.3) {
                            addLog(`        ‚ö†Ô∏è PREMI√àRE VALEUR TROP √âLEV√âE! Correction en cours...`, 'warning');
                            // CORRECTION: Limiter la premi√®re valeur √† 20% max
                            values[0] = Math.min(values[0], 0.2);
                            addLog(`        ‚úÖ Premi√®re valeur corrig√©e: ${(values[0] * 100).toFixed(1)}%`, 'success');
                        }
                    }
                    
                    // DEBUG: V√©rifier les valeurs pour d√©tecter les anomalies
                    const totalValues = values.reduce((sum, val) => sum + val, 0);
                    const maxValue = Math.max(...values);
                    const maxIndex = values.indexOf(maxValue);
                    
                    addLog(`      üìä ANALYSE DES VALEURS:`, 'info');
                    addLog(`        Total: ${(totalValues * 100).toFixed(1)}%`, 'info');
                    addLog(`        Valeur max: ${(maxValue * 100).toFixed(1)}% (position ${maxIndex + 1})`, 'info');
                    
                    // NOUVELLE APPROCHE: Normaliser les valeurs pour √©viter le d√©bordement
                    if (maxValue > 0.25) {
                        addLog(`        ‚ö†Ô∏è VALEUR TROP √âLEV√âE! Normalisation en cours...`, 'warning');
                        
                        // Calculer le facteur de normalisation pour que la valeur max = 25%
                        const normalizationFactor = 0.25 / maxValue;
                        values = values.map(val => val * normalizationFactor);
                        
                        addLog(`        üîß Facteur de normalisation: ${normalizationFactor.toFixed(3)}`, 'info');
                        addLog(`        ‚úÖ Valeurs normalis√©es (max 25%)`, 'success');
                        
                        // Afficher les nouvelles valeurs
                        addLog(`        üìä Valeurs apr√®s normalisation:`, 'info');
                        values.forEach((val, index) => {
                            addLog(`          ${index + 1}. ${(val * 100).toFixed(1)}%`, 'info');
                        });
                    }
                } else if (chartType === 'SEXE') {
                    // NOUVELLE LOGIQUE: SEXE = Donn√©es Homme/Femme
                    // Les donn√©es viennent de la sheet "Audience" colonnes Q et R
                    
                    addLog(`      üë• TRAITEMENT DONN√âES SEXE (Homme/Femme)`, 'info');
                    addLog(`      üìã Source: Sheet "Audience", colonnes Q et R`, 'info');
                    
                    const sexePattern = /([^:]+): ([\d.]+)%/g;
                    const sexeMatches = [...dataString.matchAll(sexePattern)];
                    values = sexeMatches.map(match => parseFloat(match[2]) / 100);
                    
                    addLog(`      üîç Correspondances SEXE trouv√©es: ${sexeMatches.length}`, 'info');
                    sexeMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" ‚Üí ${match[2]}%`, 'info');
                    });
                } else if (chartType === 'GRAPH_PROV') {
                    // Traitement GRAPH_PROV avec les vraies donn√©es de provenance
                    addLog(`      üèòÔ∏è TRAITEMENT GRAPH_PROV: Donn√©es de provenance r√©elles`, 'info');
                    
                    // V√©rification suppl√©mentaire : s'assurer que ce ne sont pas des donn√©es CSP
                    if (dataString.includes('Cadres') || dataString.includes('Employ√©s') || dataString.includes('Ouvriers')) {
                        addLog(`      ‚ö†Ô∏è GRAPH_PROV contient des donn√©es CSP - Ignor√©`, 'warning');
                        return xmlContent; // Retourner le XML non modifi√©
                    }
                    
                    const communePattern = /([^:]+): ([\d.]+)%/g;
                    const communeMatches = [...dataString.matchAll(communePattern)];
                    
                    // Filtrer pour exclure "Autres" des villes (garder seulement les vraies villes)
                    const cityMatches = communeMatches.filter(match => 
                        !match[1].toLowerCase().includes('autres') && 
                        !match[1].toLowerCase().includes('autre')
                    );
                    
                    values = cityMatches.map(match => parseFloat(match[2]) / 100); // Ne pas multiplier par 10
                    
                    addLog(`      üîç Correspondances GRAPH_PROV trouv√©es: ${communeMatches.length} (total)`, 'info');
                    addLog(`      üèôÔ∏è Vraies villes (sans "Autres"): ${cityMatches.length}`, 'info');
                    
                    communeMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" ‚Üí ${match[2]}%`, 'info');
                    });
                    
                    // V√©rifier que nous avons bien 6 villes pour le template
                    if (cityMatches.length === 6) {
                        addLog(`      ‚úÖ Template GRAPH_PROV: 6 villes d√©tect√©es (correspond au template)`, 'success');
                    } else {
                        addLog(`      ‚ö†Ô∏è Template GRAPH_PROV: ${cityMatches.length} villes d√©tect√©es (template attend 6 villes)`, 'warning');
                    }
                    
                    // NOUVELLE FONCTIONNALIT√â: Remplacer les placeholders de l√©gende dans le XML
                    addLog(`      üèôÔ∏è REMPLACEMENT DES PLACEHOLDERS DE L√âGENDE DANS LE XML...`, 'info');
                    
                    // Cr√©er le mapping des placeholders vers les vrais noms de villes (seulement les vraies villes)
                    const cityNames = cityMatches.map(match => {
                        // Nettoyer les noms de villes : supprimer les virgules et espaces
                        let cleanCityName = match[1].trim();
                        cleanCityName = cleanCityName.replace(/^,\s*/, ''); // Supprimer virgule au d√©but
                        cleanCityName = cleanCityName.replace(/,\s*$/, ''); // Supprimer virgule √† la fin
                        cleanCityName = cleanCityName.replace(/,/g, ''); // Supprimer toutes les autres virgules
                        cleanCityName = cleanCityName.replace(/\s+/g, ' '); // Remplacer les espaces multiples par un seul
                        cleanCityName = cleanCityName.trim(); // Supprimer les espaces en d√©but/fin
                        return cleanCityName;
                    });
                    
                    const legendPlaceholderMapping = {};
                    cityNames.forEach((cityName, index) => {
                        const placeholderKey = `{Ville${index + 1}}`; // Ville1, Ville2, Ville3, Ville4, Ville5, Ville6
                        legendPlaceholderMapping[placeholderKey] = cityName;
                        addLog(`        üó∫Ô∏è Mapping l√©gende: ${placeholderKey} ‚Üí "${cityName}"`, 'info');
                    });
                    
                    // Remplacer les placeholders dans le XML
                    let xmlWithLegendReplacements = xmlContent;
                    for (const [placeholder, cityName] of Object.entries(legendPlaceholderMapping)) {
                        // Rechercher et remplacer dans les balises XML de l√©gende
                        const legendPatterns = [
                            new RegExp(`(<c:pt[^>]*>\\s*<c:v>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*</c:v>\\s*</c:pt>)`, 'g'),
                            new RegExp(`(<c:tx>\\s*<c:rich>.*?<c:t>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*</c:t>.*?</c:rich>\\s*</c:tx>)`, 'g'),
                            new RegExp(`(<c:strRef>.*?<c:strCache>.*?<c:pt[^>]*>\\s*<c:v>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*</c:v>\\s*</c:pt>.*?</c:strCache>.*?</c:strRef>)`, 'g')
                        ];
                        
                        legendPatterns.forEach((pattern, patternIndex) => {
                            const matches = xmlWithLegendReplacements.match(pattern);
                            if (matches) {
                                addLog(`        üîç Pattern ${patternIndex + 1}: ${matches.length} occurrences de ${placeholder} trouv√©es`, 'info');
                                xmlWithLegendReplacements = xmlWithLegendReplacements.replace(pattern, `$1${cityName}$2`);
                                addLog(`        üèôÔ∏è L√©gende XML: ${placeholder} ‚Üí "${cityName}" (pattern ${patternIndex + 1})`, 'success');
                            }
                        });
                        
                        // Recherche simple dans tout le XML (fallback)
                        if (xmlWithLegendReplacements.includes(placeholder)) {
                            xmlWithLegendReplacements = xmlWithLegendReplacements.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                            addLog(`        üèôÔ∏è L√©gende XML (fallback): ${placeholder} ‚Üí "${cityName}"`, 'success');
                        }
                        
                        // APPROCHE ULTRA-AGRESSIVE: Rechercher dans toutes les balises XML possibles
                        const aggressivePatterns = [
                            new RegExp(`(>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*<)`, 'g'),
                            new RegExp(`("\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*")`, 'g'),
                            new RegExp(`(\\s+)${placeholder.replace(/[{}]/g, '\\$&')}(\\s+)`, 'g')
                        ];
                        
                        aggressivePatterns.forEach((pattern, patternIndex) => {
                            const matches = xmlWithLegendReplacements.match(pattern);
                            if (matches) {
                                addLog(`        üîç Pattern agressif ${patternIndex + 1}: ${matches.length} occurrences de ${placeholder} trouv√©es`, 'info');
                                xmlWithLegendReplacements = xmlWithLegendReplacements.replace(pattern, `$1${cityName}$2`);
                                addLog(`        üèôÔ∏è L√©gende XML (agressif ${patternIndex + 1}): ${placeholder} ‚Üí "${cityName}"`, 'success');
                            }
                        });
                    }
                    
                    // Utiliser le XML modifi√© pour la suite du traitement
                    xmlContent = xmlWithLegendReplacements;
                }
                
                addLog(`      üìä ${values.length} valeurs √† injecter: [${values.map(v => (v * 100).toFixed(1) + '%').join(', ')}]`, 'info');
                
                if (values.length === 0) {
                    addLog(`      ‚ùå Aucune donn√©e valide pour ${chartType}`, 'error');
                    return xmlContent;
                }
                
                // NOUVELLE VALIDATION: V√©rifier que le nombre de valeurs correspond au type de graphique
                const expectedValuesCount = getExpectedValuesCount(chartType);
                if (expectedValuesCount > 0 && values.length !== expectedValuesCount) {
                    addLog(`      ‚ö†Ô∏è Nombre de valeurs inattendu pour ${chartType}: ${values.length} au lieu de ${expectedValuesCount}`, 'warning');
                    addLog(`      üîÑ Continuation malgr√© l'√©cart...`, 'info');
                }
                
                let modifiedXml = xmlContent;
                let totalModifications = 0;
                
                // APPROCHE STRICTE: Emp√™cher le m√©lange des donn√©es en utilisant une validation stricte
                addLog(`      üîí VALIDATION STRICTE POUR √âVITER LE M√âLANGE DES DONN√âES`, 'info');
                
                // NOUVELLE APPROCHE: Utiliser le contexte d'appel pour d√©terminer si ce graphique doit √™tre modifi√©
                const shouldModifyChart = shouldModifyThisChart(xmlContent, chartType);
                addLog(`      üîç Ce graphique doit-il √™tre modifi√© pour ${chartType}? ${shouldModifyChart ? 'OUI' : 'NON'}`, 'info');
                
                if (!shouldModifyChart) {
                    addLog(`      üö´ Graphique ignor√© - Pas de modification pour √©viter le m√©lange des donn√©es`, 'warning');
                    return xmlContent;
                }
                
                addLog(`      ‚úÖ Graphique valid√© - Application des donn√©es ${chartType}`, 'success');
                    
                    // DEBUG: Afficher la structure XML pour comprendre le probl√®me
                addLog(`      üîç DEBUG: Analyse de la structure XML pour ${chartType}...`, 'info');
                
                // Chercher toutes les balises <c:v> dans le XML
                const allVTags = modifiedXml.match(/<c:v>[^<]*<\/c:v>/g) || [];
                addLog(`      üìã Balises <c:v> trouv√©es: ${allVTags.length}`, 'info');
                allVTags.slice(0, 10).forEach((tag, index) => {
                    addLog(`        ${index + 1}. ${tag}`, 'info');
                });
                
                // Chercher toutes les balises <c:val> dans le XML
                const allValTags = modifiedXml.match(/<c:val>[^<]*<\/c:val>/g) || [];
                addLog(`      üìã Balises <c:val> trouv√©es: ${allValTags.length}`, 'info');
                allValTags.slice(0, 10).forEach((tag, index) => {
                    addLog(`        ${index + 1}. ${tag}`, 'info');
                });
                
                // DEBUG √âTENDU: Chercher d'autres patterns de valeurs num√©riques
                const numericPatterns = [
                    /<c:pt[^>]*>[\s\S]*?<c:v>([0-9.]+)<\/c:v>[\s\S]*?<\/c:pt>/g,
                    /<c:numRef>[\s\S]*?<c:numCache>[\s\S]*?<c:pt[^>]*>[\s\S]*?<c:v>([0-9.]+)<\/c:v>[\s\S]*?<\/c:pt>[\s\S]*?<\/c:numCache>[\s\S]*?<\/c:numRef>/g,
                    /<c:val>([0-9.]+)<\/c:val>/g,
                    /<c:v>([0-9.]+)<\/c:v>/g
                ];
                
                numericPatterns.forEach((pattern, index) => {
                    const matches = modifiedXml.match(pattern);
                    if (matches && matches.length > 0) {
                        addLog(`      üìã Pattern ${index + 1} trouv√©: ${matches.length} occurrences`, 'info');
                        matches.slice(0, 5).forEach((match, matchIndex) => {
                            addLog(`        ${matchIndex + 1}. ${match.substring(0, 100)}...`, 'info');
                        });
                    }
                });
                
                // DEBUG: Afficher un √©chantillon du XML pour voir la structure
                const xmlSample = modifiedXml.substring(0, 2000);
                addLog(`      üìÑ √âchantillon XML (2000 caract√®res):`, 'info');
                addLog(`      ${xmlSample.replace(/\n/g, ' ').substring(0, 500)}...`, 'info');
                
                // APPROCHE ULTRA-AGRESSIVE: Chercher TOUTES les valeurs num√©riques dans le XML
                addLog(`      üîç RECHERCHE ULTRA-AGRESSIVE DE VALEURS NUM√âRIQUES...`, 'info');
                
                // Chercher toutes les valeurs num√©riques possibles
                const allNumericValues = modifiedXml.match(/\b(0\.\d+)\b/g) || [];
                addLog(`      üìä Valeurs num√©riques trouv√©es: ${allNumericValues.length}`, 'info');
                allNumericValues.slice(0, 10).forEach((value, index) => {
                    addLog(`        ${index + 1}. ${value}`, 'info');
                });
                
                // APPROCHE 1: Modifier toutes les valeurs <c:v> de mani√®re s√©quentielle
                const allValuesPattern = /<c:v>([0-9.]+)<\/c:v>/g;
                let matchCount = 0;
                
                modifiedXml = modifiedXml.replace(allValuesPattern, (match, currentValue) => {
                    if (matchCount < values.length) {
                        const newValue = values[matchCount];
                        addLog(`        ‚úÖ Valeur ${chartType} ${matchCount + 1}: ${currentValue} ‚Üí ${newValue} (${(newValue * 100).toFixed(1)}%)`, 'success');
                        matchCount++;
                        totalModifications++;
                        return `<c:v>${newValue}</c:v>`;
                    }
                    return match;
                });
                
                // APPROCHE 2: Si pas de balises <c:v>, essayer de remplacer directement les valeurs num√©riques
                if (totalModifications === 0 && allNumericValues.length > 0) {
                    addLog(`      üîÑ APPROCHE DIRECTE: Remplacement des valeurs num√©riques...`, 'info');
                    
                    // Trier les valeurs par ordre d√©croissant pour √©viter les conflits
                    const sortedValues = [...values].sort((a, b) => b - a);
                    let directMatchCount = 0;
                    
                    // Remplacer les valeurs une par une
                    for (let i = 0; i < Math.min(sortedValues.length, allNumericValues.length); i++) {
                        const oldValue = allNumericValues[i];
                        const newValue = sortedValues[i];
                        
                        if (parseFloat(oldValue) !== newValue) { // √âviter de remplacer par la m√™me valeur
                            const beforeCount = (modifiedXml.match(new RegExp(`\\b${oldValue}\\b`, 'g')) || []).length;
                            if (beforeCount > 0) {
                                modifiedXml = modifiedXml.replace(new RegExp(`\\b${oldValue}\\b`, 'g'), newValue.toString());
                                addLog(`        ‚úÖ Valeur directe ${i + 1}: ${oldValue} ‚Üí ${newValue} (${(newValue * 100).toFixed(1)}%)`, 'success');
                                directMatchCount += beforeCount;
                            }
                        }
                    }
                    
                    totalModifications += directMatchCount;
                }
                
                // APPROCHE SP√âCIALE POUR GRAPH_PROV: G√©rer la valeur "Autre" s√©par√©ment
                if (chartType === 'GRAPH_PROV') {
                    addLog(`      üîÑ GESTION SP√âCIALE DE LA VALEUR "AUTRE"...`, 'info');
                    
                    // Calculer la valeur "Autre" (ce qui reste pour arriver √† 100%)
                    const totalVilles = values.reduce((sum, val) => sum + val, 0);
                    const valeurAutre = Math.max(0, 1 - totalVilles); // 1 = 100%
                    
                    addLog(`      üìä Valeur "Autre" calcul√©e: ${(valeurAutre * 100).toFixed(1)}%`, 'info');
                    
                    // Chercher et remplacer la valeur 0.70 (70% du template) par la vraie valeur "Autre"
                    const templateAutreValue = '0.70';
                    const beforeCount = (modifiedXml.match(new RegExp(`\\b${templateAutreValue}\\b`, 'g')) || []).length;
                    if (beforeCount > 0) {
                        modifiedXml = modifiedXml.replace(new RegExp(`\\b${templateAutreValue}\\b`, 'g'), valeurAutre.toString());
                        addLog(`        ‚úÖ Valeur "Autre": ${templateAutreValue} ‚Üí ${valeurAutre} (${(valeurAutre * 100).toFixed(1)}%)`, 'success');
                        totalModifications += beforeCount;
                    } else {
                        addLog(`        ‚ö†Ô∏è Valeur template "Autre" (0.70) non trouv√©e dans le XML`, 'warning');
                        
                        // Chercher d'autres valeurs possibles pour "Autre"
                        const autresValeurs = ['0.7', '0.700', '70', '0.69', '0.71'];
                        for (const autreVal of autresValeurs) {
                            const count = (modifiedXml.match(new RegExp(`\\b${autreVal}\\b`, 'g')) || []).length;
                            if (count > 0) {
                                modifiedXml = modifiedXml.replace(new RegExp(`\\b${autreVal}\\b`, 'g'), valeurAutre.toString());
                                addLog(`        ‚úÖ Valeur "Autre" alternative: ${autreVal} ‚Üí ${valeurAutre} (${(valeurAutre * 100).toFixed(1)}%)`, 'success');
                                totalModifications += count;
                                break;
                            }
                        }
                    }
                }
                
                // NOUVELLE APPROCHE: Modifier aussi les l√©gendes dans le XML (pas seulement les valeurs)
                if (chartType === 'GRAPH_PROV') {
                    addLog(`      üèôÔ∏è REMPLACEMENT DES L√âGENDES DANS LE XML (pas Excel embarqu√©)...`, 'info');
                    
                    // Recr√©er le mapping des placeholders pour cette fonction
                    const communePattern = /([^:]+): ([\d.]+)%/g;
                    const communeMatches = [...dataString.matchAll(communePattern)];
                    const cityMatches = communeMatches.filter(match => 
                        !match[1].toLowerCase().includes('autres') && 
                        !match[1].toLowerCase().includes('autre')
                    );
                    
                    const cityNames = cityMatches.map(match => {
                        let cleanCityName = match[1].trim();
                        cleanCityName = cleanCityName.replace(/^,\s*/, '');
                        cleanCityName = cleanCityName.replace(/,\s*$/, '');
                        cleanCityName = cleanCityName.replace(/,/g, '');
                        cleanCityName = cleanCityName.replace(/\s+/g, ' ');
                        cleanCityName = cleanCityName.trim();
                        return cleanCityName;
                    });
                    
                    const legendPlaceholderMapping = {};
                    cityNames.forEach((cityName, index) => {
                        const placeholderKey = `{Ville${index + 1}}`;
                        legendPlaceholderMapping[placeholderKey] = cityName;
                        addLog(`        üó∫Ô∏è Mapping l√©gende: ${placeholderKey} ‚Üí "${cityName}"`, 'info');
                    });
                    
                    // Remplacer les placeholders de l√©gende dans le XML
                    for (const [placeholder, cityName] of Object.entries(legendPlaceholderMapping)) {
                        // Recherche agressive dans tout le XML
                        const beforeCount = (modifiedXml.match(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g')) || []).length;
                        if (beforeCount > 0) {
                            modifiedXml = modifiedXml.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                            addLog(`        üèôÔ∏è L√©gende XML: ${placeholder} ‚Üí "${cityName}" (${beforeCount} occurrences)`, 'success');
                            totalModifications += beforeCount;
                        }
                    }
                }
                
                    // Si pas assez de valeurs trouv√©es avec <c:v>, essayer avec <c:val>
                if (totalModifications === 0) {
                    addLog(`      üîÑ Tentative avec les balises <c:val>...`, 'info');
                    const valPattern = /<c:val>([^<]*)<\/c:val>/g;
                    matchCount = 0;
                    
                    modifiedXml = modifiedXml.replace(valPattern, (match, currentValue) => {
                        if (matchCount < values.length) {
                            const newValue = values[matchCount];
                                addLog(`        ‚úÖ Valeur <c:val> ${chartType} ${matchCount + 1}: ${currentValue} ‚Üí ${newValue} (${(newValue * 100).toFixed(1)}%)`, 'success');
                            matchCount++;
                            totalModifications++;
                            return `<c:val>${newValue}</c:val>`;
                        }
                        return match;
                    });
                }
                
                addLog(`      üìä ${totalModifications} valeurs XML modifi√©es au total`, 'info');
                return modifiedXml;
                
            } catch (error) {
                addLog(`      ‚ùå Erreur mise √† jour XML ${chartType}: ${error.message}`, 'error');
                return xmlContent;
            }
        }

        // Fonction pour d√©tecter le type de graphique dans le XML
        function detectChartTypeInXml(xmlContent) {
            try {
                addLog(`      üîç ANALYSE D√âTAILL√âE DU XML POUR D√âTECTION DE TYPE`, 'info');
                
                // Afficher un √©chantillon du XML pour debug
                const sampleLength = Math.min(1000, xmlContent.length);
                const xmlSample = xmlContent.substring(0, sampleLength);
                addLog(`      üìÑ √âchantillon XML (${sampleLength} caract√®res):`, 'info');
                addLog(`      ${xmlSample.replace(/\n/g, ' ').substring(0, 300)}...`, 'info');
                
                // Chercher les identifiants de type de graphique dans le XML (PANE NAMING PowerPoint)
                if (xmlContent.includes('GRAPH_AGE')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_AGE (PANE NAMING) trouv√©`, 'success');
                    return 'AGE';
                } else if (xmlContent.includes('GRAPH_CSP')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_CSP (PANE NAMING) trouv√©`, 'success');
                    return 'CSP';
                } else if (xmlContent.includes('GRAPH_SEXE')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_SEXE (PANE NAMING) trouv√©`, 'success');
                    return 'SEXE';
                } else if (xmlContent.includes('GRAPH_PROV')) {
                    // V√©rification suppl√©mentaire : s'assurer que ce n'est pas un graphique CSP
                    if (xmlContent.includes('Cadres') || xmlContent.includes('Employ√©s') || xmlContent.includes('Ouvriers')) {
                        addLog(`      ‚ö†Ô∏è GRAPH_PROV contient des patterns CSP - Trait√© comme CSP`, 'warning');
                        return 'CSP';
                    }
                    addLog(`      ‚úÖ Identifiant GRAPH_PROV (PANE NAMING) trouv√© - TEST`, 'success');
                    return 'GRAPH_PROV';
                }
                
                // Chercher des patterns sp√©cifiques dans les labels ou donn√©es
                if (xmlContent.includes('15-24 ans') || xmlContent.includes('25-34 ans') || xmlContent.includes('35-49 ans')) {
                    addLog(`      ‚úÖ Patterns d'√¢ge d√©tect√©s dans le XML`, 'success');
                    return 'AGE';
                } else if (xmlContent.includes('Agriculteurs') || xmlContent.includes('Cadres') || xmlContent.includes('Employ√©s')) {
                    addLog(`      ‚úÖ Patterns CSP d√©tect√©s dans le XML`, 'success');
                    return 'CSP';
                } else if (xmlContent.includes('Homme') || xmlContent.includes('Femme')) {
                    addLog(`      ‚úÖ Patterns de sexe (Homme/Femme) d√©tect√©s dans le XML`, 'success');
                    return 'SEXE';
                }
                
                addLog(`      ‚ùå Aucun pattern de type de graphique d√©tect√©`, 'warning');
                return null; // Type non d√©tect√©
            } catch (error) {
                addLog(`      ‚ùå Erreur d√©tection type graphique: ${error.message}`, 'error');
                return null;
            }
        }

        // Fonction pour d√©terminer si un graphique doit √™tre modifi√© (approche stricte)
        function shouldModifyThisChart(xmlContent, chartType) {
            try {
                addLog(`      üîç ANALYSE STRICTE DU GRAPHIQUE POUR ${chartType}`, 'info');
                
                // 1. Chercher des identifiants explicites dans le XML (PANE NAMING PowerPoint)
                if (chartType === 'AGE' && xmlContent.includes('GRAPH_AGE')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_AGE (PANE NAMING) trouv√©`, 'success');
                    return true;
                } else if (chartType === 'CSP' && xmlContent.includes('GRAPH_CSP')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_CSP (PANE NAMING) trouv√©`, 'success');
                    return true;
                } else if (chartType === 'SEXE' && xmlContent.includes('GRAPH_SEXE')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_SEXE (PANE NAMING) trouv√©`, 'success');
                    return true;
                } else if (chartType === 'GRAPH_PROV' && xmlContent.includes('GRAPH_PROV')) {
                    addLog(`      ‚úÖ Identifiant GRAPH_PROV (PANE NAMING) trouv√© - TEST`, 'success');
                    // V√©rification suppl√©mentaire : s'assurer que ce n'est pas un graphique CSP
                    if (xmlContent.includes('Cadres') || xmlContent.includes('Employ√©s') || xmlContent.includes('Ouvriers')) {
                        addLog(`      ‚ö†Ô∏è GRAPH_PROV contient des patterns CSP - Ignor√© pour √©viter le conflit`, 'warning');
                        return false;
                    }
                    return true;
                }
                
                // 2. Chercher des patterns de donn√©es sp√©cifiques
                if (chartType === 'AGE') {
                    const agePatterns = ['15-24 ans', '25-34 ans', '35-49 ans', '50-64 ans', '65 ans'];
                    const hasAgePattern = agePatterns.some(pattern => xmlContent.includes(pattern));
                    if (hasAgePattern) {
                        addLog(`      ‚úÖ Patterns d'√¢ge d√©tect√©s dans le XML`, 'success');
                        return true;
                    }
                    
                    // NOUVELLE APPROCHE: Chercher des patterns plus g√©n√©riques
                    const genericAgePatterns = ['ans', 'age', 'tranche', 'groupe'];
                    const hasGenericPattern = genericAgePatterns.some(pattern => xmlContent.toLowerCase().includes(pattern));
                    if (hasGenericPattern) {
                        addLog(`      ‚úÖ Patterns g√©n√©riques d'√¢ge d√©tect√©s dans le XML`, 'success');
                    return true;
                    }
                    
                    // APPROCHE CONSERVATRICE: Si aucun pattern sp√©cifique, NE PAS modifier pour √©viter le m√©lange
                    addLog(`      ‚ùå Aucun pattern d'√¢ge sp√©cifique trouv√© - Graphique ignor√© pour √©viter le m√©lange`, 'warning');
                    return false;
                } else if (chartType === 'CSP') {
                    // V√âRIFICATION STRICTE: Ne pas appliquer CSP si c'est un graphique GRAPH_PROV
                    if (xmlContent.includes('GRAPH_PROV')) {
                        addLog(`      üö´ GRAPH_PROV d√©tect√© - CSP ignor√© pour √©viter le m√©lange`, 'warning');
                        return false;
                    }
                    
                    // DEBUG: Analyser le contenu XML pour CSP
                    addLog(`      üîç ANALYSE XML CSP - √âchantillon:`, 'info');
                    const xmlSample = xmlContent.substring(0, 500).replace(/\n/g, ' ');
                    addLog(`      ${xmlSample}...`, 'info');
                    
                    const cspPatterns = [
                        'Cadres et professions intellectuelles sup.',
                        'Professions interm√©diaires',
                        'Artisans, commer√ßants et chefs d\'entreprise',
                        'Employ√©s',
                        'Ouvriers',
                        'Agriculteurs exploitants',
                        'El√®ves, √©tudiants, stagiaires',
                        'Retrait√©s',
                        'Autres personnes sans activit√© pro',
                        // Patterns partiels pour compatibilit√©
                        'Cadres', 'Artisans', 'Agriculteurs', '√âtudiants', 'Employ√©s', 'Ouvriers', 'Retrait√©s'
                    ];
                    const hasCspPattern = cspPatterns.some(pattern => xmlContent.includes(pattern));
                    if (hasCspPattern) {
                        addLog(`      ‚úÖ Patterns CSP d√©tect√©s dans le XML`, 'success');
                        return true;
                    }
                    
                    // NOUVELLE APPROCHE: Chercher des patterns plus g√©n√©riques pour CSP
                    const genericCspPatterns = ['profession', 'cat√©gorie', 'socio', 'csp', 'm√©tier', 'emploi', 'travail'];
                    const hasGenericCspPattern = genericCspPatterns.some(pattern => xmlContent.toLowerCase().includes(pattern));
                    if (hasGenericCspPattern) {
                        addLog(`      ‚úÖ Patterns g√©n√©riques CSP d√©tect√©s dans le XML`, 'success');
                    return true;
                    }
                    
                    // NOUVELLE APPROCHE: Analyser le nombre de valeurs pour d√©tecter un graphique CSP
                    const valueCount = (xmlContent.match(/<c:v>([0-9.]+)<\/c:v>/g) || []).length;
                    if (valueCount >= 6 && valueCount <= 12) {
                        addLog(`      ‚úÖ Graphique CSP d√©tect√© par nombre de valeurs (${valueCount})`, 'success');
                        return true;
                    }
                    
                    // NOUVELLE APPROCHE: Chercher des patterns de graphique en barres horizontales (typique des CSP)
                    if (xmlContent.includes('<c:barChart') || xmlContent.includes('<c:barDir val="bar"')) {
                        addLog(`      ‚úÖ Graphique en barres d√©tect√© (typique des CSP)`, 'success');
                        return true;
                    }
                    
                    // APPROCHE CONSERVATRICE: Si aucun pattern sp√©cifique, NE PAS modifier pour √©viter le m√©lange
                    addLog(`      ‚ùå Aucun pattern CSP sp√©cifique trouv√© - Graphique ignor√© pour √©viter le m√©lange`, 'warning');
                    return false;
                } else if (chartType === 'SEXE') {
                    // NOUVELLE LOGIQUE: SEXE = Homme/Femme uniquement
                    const sexePatterns = ['Homme', 'Femme', 'Masculin', 'F√©minin'];
                    const hasSexePattern = sexePatterns.some(pattern => xmlContent.includes(pattern));
                    if (hasSexePattern) {
                        addLog(`      ‚úÖ Patterns de sexe (Homme/Femme) d√©tect√©s dans le XML`, 'success');
                        return true;
                    }
                    
                    addLog(`      ‚ùå Aucun pattern de sexe trouv√© - Graphique ignor√©`, 'warning');
                    return false;
                }
                
                // 3. APPROCHE CONSERVATRICE: Si aucun pattern sp√©cifique trouv√©, ne pas modifier
                addLog(`      ‚ùå Aucun pattern sp√©cifique √† ${chartType} trouv√© - Graphique ignor√© pour √©viter le m√©lange`, 'warning');
                return false;
                
            } catch (error) {
                addLog(`      ‚ùå Erreur validation graphique: ${error.message}`, 'error');
                return false; // En cas d'erreur, ne pas modifier pour √©viter les probl√®mes
            }
        }

        // Fonction pour parser les donn√©es de la colonne "R√©seau"
        function parseNetworkData(networkString) {
            try {
                addLog(`    üîç PARSING DU R√âSEAU: "${networkString}"`, 'info');
                
                // Format attendu: "Vannes - temporaire - 7 jours - flanc_gauche - 40 faces"
                const parts = networkString.split(' - ');
                
                if (parts.length >= 5) {
                    const ville = parts[0].trim();
                    const type = parts[1].trim(); // temporaire
                    const duree = parts[2].trim(); // 7 jours ou 14 jours
                    const face = parts[3].trim(); // flanc_gauche, flanc_droit, arriere
                    const faces = parts[4].trim(); // 40 faces
                    
                    // Calculer la semaine (pour l'instant, on utilise la semaine actuelle)
                    const currentWeek = getCurrentWeek();
                    
                    // Normaliser les noms de face
                    const normalizedFace = normalizeFaceName(face);
                    
                    return {
                        ville: ville,
                        type: type,
                        duree: duree,
                        face: normalizedFace,
                        faces: faces,
                        semaine: currentWeek,
                        original: networkString
                    };
                } else {
                    addLog(`    ‚ö†Ô∏è Format r√©seau non reconnu: ${networkString}`, 'warning');
                    return {
                        ville: 'Inconnue',
                        type: 'standard',
                        duree: '7 jours',
                        face: 'standard',
                        faces: 'standard',
                        semaine: getCurrentWeek(),
                        original: networkString
                    };
                }
            } catch (error) {
                addLog(`    ‚ùå Erreur parsing r√©seau: ${error.message}`, 'error');
                return {
                    ville: 'Erreur',
                    type: 'standard',
                    duree: '7 jours',
                    face: 'standard',
                    faces: 'standard',
                    semaine: getCurrentWeek(),
                    original: networkString
                };
            }
        }

        // Fonction pour normaliser les noms de face
        function normalizeFaceName(face) {
            const faceMap = {
                'flanc_gauche': 'Flanc Gauche',
                'flanc_droit': 'Flanc Droit',
                'arriere': 'Arri√®re',
                'flanc gauche': 'Flanc Gauche',
                'flanc droit': 'Flanc Droit',
                'arri√®re': 'Arri√®re'
            };
            
            const normalized = faceMap[face.toLowerCase()] || face;
            addLog(`    üîÑ Face normalis√©e: "${face}" ‚Üí "${normalized}"`, 'info');
            return normalized;
        }

        // Fonction pour calculer la semaine actuelle
        function getCurrentWeek() {
            const now = new Date();
            const start = new Date(now.getFullYear(), 0, 1);
            const days = Math.floor((now - start) / (24 * 60 * 60 * 1000));
            const weekNumber = Math.ceil((days + start.getDay() + 1) / 7);
            return Math.min(weekNumber, 52); // Max 52 semaines
        }

        // Fonction pour cr√©er la hi√©rarchie de dossiers
        function createFileHierarchy(networkData, fileName) {
            try {
                // Structure: ANNEE - Rapports d'audience Buster/SEMAINE/VILLE/FACE/VERSION/fichier
                const currentYear = new Date().getFullYear();
                const parentFolder = `${currentYear} - Rapports d'audience Buster`;
                const semaine = `Semaine ${networkData.semaine}`;
                const ville = networkData.ville;
                const face = networkData.face;
                const version = networkData.duree === '7 jours' ? 'Version 7 jours' : 'Version 14 jours';
                
                const filePath = `${parentFolder}/${semaine}/${ville}/${face}/${version}/${fileName}`;
                
                addLog(`    üìÅ Chemin cr√©√©: ${filePath}`, 'info');
                return filePath;
                
            } catch (error) {
                addLog(`    ‚ùå Erreur cr√©ation hi√©rarchie: ${error.message}`, 'error');
                return fileName; // Fallback
            }
        }

        // Fonction pour traiter le fichier Excel embarqu√© pour GRAPH_PROV
        async function processEmbeddedExcelForGraphProv(zip, slideFile, templateData, row, excelData) {
            try {
                addLog(`    üîç RECHERCHE DU FICHIER EXCEL EMBARQU√â POUR GRAPH_PROV...`, 'info');
                
                // 1. Chercher les fichiers Excel embarqu√©s
                const embeddedFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('embeddings/') && relativePath.endsWith('.xlsx')) {
                        embeddedFiles.push(relativePath);
                    }
                });
                
                addLog(`    üìã ${embeddedFiles.length} fichiers Excel embarqu√©s trouv√©s`, 'info');
                
                // 2. Pour chaque fichier Excel embarqu√©, chercher GRAPH_PROV
                for (const excelFile of embeddedFiles) {
                    try {
                        addLog(`    üîç Analyse de ${excelFile}...`, 'info');
                        
                        // Lire le fichier Excel embarqu√©
                        const embeddedExcelBuffer = await zip.file(excelFile).async('arraybuffer');
                        const embeddedWorkbook = XLSX.read(embeddedExcelBuffer, { type: 'array' });
                        
                        // Chercher dans toutes les feuilles
                        let foundInSheet = false;
                        for (const sheetName of Object.keys(embeddedWorkbook.Sheets)) {
                            const sheet = embeddedWorkbook.Sheets[sheetName];
                            const sheetContent = XLSX.utils.sheet_to_txt(sheet);
                            
                            if (sheetContent.includes('GRAPH_PROV')) {
                                addLog(`    ‚úÖ GRAPH_PROV trouv√© dans ${excelFile}, feuille "${sheetName}"`, 'success');
                                foundInSheet = true;
                                
                                // Modifier les donn√©es dans cette feuille
                                const modified = await updateExcelSheetForGraphProv(sheet, templateData, row, excelData);
                                
                                if (modified) {
                                    // Sauvegarder le fichier Excel modifi√©
                                    const modifiedBuffer = XLSX.write(embeddedWorkbook, { type: 'array', bookType: 'xlsx' });
                                    zip.file(excelFile, modifiedBuffer);
                                    addLog(`    ‚úÖ Fichier Excel ${excelFile} modifi√© avec succ√®s`, 'success');
                                    return true;
                                }
                            }
                            else if (sheetContent.includes('GRAPHIQUE PROVENANCE')) {
                                addLog(`    üîç "GRAPHIQUE PROVENANCE" trouv√© dans ${excelFile}, feuille "${sheetName}"`, 'warning');
                                foundInSheet = true;
                                
                                // Modifier les donn√©es dans cette feuille
                                const modified = await updateExcelSheetForGraphProv(sheet, templateData, row, excelData);
                                
                                if (modified) {
                                    // Sauvegarder le fichier Excel modifi√©
                                    const modifiedBuffer = XLSX.write(embeddedWorkbook, { type: 'array', bookType: 'xlsx' });
                                    zip.file(excelFile, modifiedBuffer);
                                    addLog(`    ‚úÖ Fichier Excel ${excelFile} modifi√© avec succ√®s`, 'success');
                                    return true;
                                }
                            }
                        }
                        
                        if (!foundInSheet) {
                            addLog(`    ‚ùå GRAPH_PROV non trouv√© dans ${excelFile}`, 'info');
                        }
                        
                    } catch (error) {
                        addLog(`    ‚ö†Ô∏è Erreur traitement ${excelFile}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`    ‚ùå Aucun fichier Excel embarqu√© contenant GRAPH_PROV trouv√©`, 'warning');
                return false;
                
            } catch (error) {
                addLog(`    ‚ùå Erreur recherche Excel embarqu√©: ${error.message}`, 'error');
                return false;
            }
        }

        // Fonction pour mettre √† jour une feuille Excel pour GRAPH_PROV
        async function updateExcelSheetForGraphProv(sheet, templateData, row, excelData) {
            try {
                addLog(`      üîÑ MISE √Ä JOUR DE LA FEUILLE EXCEL POUR GRAPH_PROV`, 'info');
                
                // 1. Obtenir les donn√©es de provenance
                const graphProvData = await processGraphProvData(row, excelData);
                if (!graphProvData) {
                    addLog(`      ‚ùå Impossible d'obtenir les donn√©es de provenance`, 'error');
                    return false;
                }
                
                addLog(`      üìä Donn√©es de provenance: ${graphProvData}`, 'info');
                
                // 2. Parser les donn√©es
                const communePattern = /([^:]+): ([\d.]+)%/g;
                const communeMatches = [...graphProvData.matchAll(communePattern)];
                
                // Filtrer pour exclure "Autres" des villes (garder seulement les vraies villes)
                const cityMatches = communeMatches.filter(match => 
                    !match[1].toLowerCase().includes('autres') && 
                    !match[1].toLowerCase().includes('autre')
                );
                
                const values = cityMatches.map(match => parseFloat(match[2]) / 100); // Ne pas multiplier par 10
                
                addLog(`      üìä ${values.length} valeurs √† injecter: [${values.map(v => (v * 100).toFixed(1) + '%').join(', ')}]`, 'info');
                
                // 3. ANALYSER LA STRUCTURE R√âELLE DU FICHIER EXCEL EMBARQU√â
                addLog(`      üîç ANALYSE DE LA STRUCTURE EXCEL EMBARQU√â...`, 'info');
                
                // Afficher toutes les cellules non-vides pour comprendre la structure
                const allCells = [];
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined) {
                        allCells.push({
                            ref: cellRef,
                            value: cell.v,
                            type: typeof cell.v
                        });
                    }
                }
                
                addLog(`      üìã ${allCells.length} cellules non-vides trouv√©es`, 'info');
                
                // Afficher les premi√®res cellules pour debug
                const sampleCells = allCells.slice(0, 20);
                addLog(`      üìÑ √âchantillon des cellules:`, 'info');
                sampleCells.forEach(cell => {
                    addLog(`        ${cell.ref}: "${cell.value}" (${cell.type})`, 'info');
                });
                
                // 4. NOUVELLE APPROCHE: Recherche intelligente des cellules de labels
                let modified = false;
                let valueIndex = 0;
                let labelIndex = 0;
                
                // Extraire les noms des villes (seulement les vraies villes)
                const cityNames = cityMatches.map(match => {
                    // Nettoyer les noms de villes : supprimer les virgules et espaces
                    let cleanCityName = match[1].trim();
                    cleanCityName = cleanCityName.replace(/^,\s*/, ''); // Supprimer virgule au d√©but
                    cleanCityName = cleanCityName.replace(/,\s*$/, ''); // Supprimer virgule √† la fin
                    cleanCityName = cleanCityName.replace(/,/g, ''); // Supprimer toutes les autres virgules
                    cleanCityName = cleanCityName.replace(/\s+/g, ' '); // Remplacer les espaces multiples par un seul
                    cleanCityName = cleanCityName.trim(); // Supprimer les espaces en d√©but/fin
                    return cleanCityName;
                });
                addLog(`      üèôÔ∏è Noms de villes √† injecter: [${cityNames.join(', ')}]`, 'info');
                
                // STRAT√âGIE 1: Chercher et remplacer les placeholders avec accolades {VilleX}
                addLog(`      üîç Recherche des placeholders avec accolades {VilleX}...`, 'info');
                
                // Cr√©er un mapping des placeholders vers les vrais noms de villes
                const placeholderMapping = {};
                cityNames.forEach((cityName, index) => {
                    const placeholderKey = `{Ville${index + 1}}`; // Ville1, Ville2, Ville3, Ville4, Ville5, Ville6
                    placeholderMapping[placeholderKey] = cityName;
                    addLog(`        üó∫Ô∏è Mapping: ${placeholderKey} ‚Üí "${cityName}"`, 'info');
                });
                
                // Ajouter aussi les variations possibles (au cas o√π)
                cityNames.forEach((cityName, index) => {
                    const variations = [
                        `{Ville${index + 1}}`,
                        `{ville${index + 1}}`,
                        `{VILLE${index + 1}}`,
                        `Ville${index + 1}`,
                        `ville${index + 1}`,
                        `VILLE${index + 1}`
                    ];
                    
                    variations.forEach(variation => {
                        if (!placeholderMapping[variation]) {
                            placeholderMapping[variation] = cityName;
                        }
                    });
                });
                
                // Parcourir toutes les cellules pour remplacer les placeholders
                addLog(`      üîç Recherche dans ${Object.keys(sheet).length} cellules...`, 'info');
                
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                        const cellValue = cell.v.toString();
                        
                        // V√©rifier si cette cellule contient un placeholder avec accolades
                        for (const [placeholder, cityName] of Object.entries(placeholderMapping)) {
                            if (cellValue.includes(placeholder)) {
                                const oldLabel = cell.v;
                                cell.v = cellValue.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                                addLog(`        üèôÔ∏è Placeholder ${cellRef}: "${oldLabel}" ‚Üí "${cell.v}"`, 'success');
                                modified = true;
                                break; // Sortir de la boucle des placeholders pour cette cellule
                            }
                        }
                    }
                }
                
                // APPROCHE SP√âCIFIQUE: Chercher dans les cellules qui pourraient contenir les l√©gendes
                addLog(`      üîç Recherche sp√©cifique des cellules de l√©gende...`, 'info');
                
                // Chercher les cellules qui contiennent des patterns de l√©gende
                const legendCellPatterns = ['Ville', 'ville', 'City', 'city', 'Legend', 'legend'];
                
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                        const cellValue = cell.v.toString();
                        
                        // Si cette cellule contient un pattern de l√©gende ET un placeholder
                        const hasLegendPattern = legendCellPatterns.some(pattern => 
                            cellValue.toLowerCase().includes(pattern.toLowerCase())
                        );
                        
                        if (hasLegendPattern) {
                            addLog(`        üîç Cellule de l√©gende potentielle ${cellRef}: "${cellValue}"`, 'info');
                            
                            // Essayer de remplacer les placeholders dans cette cellule
                            for (const [placeholder, cityName] of Object.entries(placeholderMapping)) {
                                if (cellValue.includes(placeholder)) {
                                    const oldLabel = cell.v;
                                    cell.v = cellValue.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                                    addLog(`        üèôÔ∏è L√©gende ${cellRef}: "${oldLabel}" ‚Üí "${cell.v}"`, 'success');
                                    modified = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // STRAT√âGIE 2: Chercher les cellules contenant des patterns de labels g√©n√©riques (fallback)
                const labelPatterns = [
                    'ville', 'city', 'commune', 'municipalit√©', 'localit√©', 'lieu',
                    'Ville', 'City', 'Commune', 'Municipalit√©', 'Localit√©', 'Lieu',
                    'ville1', 'ville2', 'ville3', 'ville4', 'ville5', 'ville6',
                    'Ville1', 'Ville2', 'Ville3', 'Ville4', 'Ville5', 'Ville6'
                ];
                
                addLog(`      üîç Recherche des cellules de labels avec patterns g√©n√©riques (fallback)...`, 'info');
                
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                        const cellValue = cell.v.toString();
                        
                        // V√©rifier si cette cellule correspond √† un pattern de label
                        const isLabelCell = labelPatterns.some(pattern => 
                            cellValue.toLowerCase().includes(pattern.toLowerCase())
                        );
                        
                        if (isLabelCell && labelIndex < cityNames.length) {
                            const oldLabel = cell.v;
                            cell.v = cityNames[labelIndex];
                            addLog(`        üèôÔ∏è Label ${cellRef}: "${oldLabel}" ‚Üí "${cell.v}" (pattern d√©tect√©)`, 'success');
                            labelIndex++;
                            modified = true;
                        }
                    }
                }
                
                // STRAT√âGIE 2: Si pas assez de labels trouv√©s, chercher les cellules vides ou avec des valeurs par d√©faut
                if (labelIndex < cityNames.length) {
                    addLog(`      üîç Recherche des cellules vides ou par d√©faut pour les labels restants...`, 'info');
                    
                    for (const cellRef in sheet) {
                        const cell = sheet[cellRef];
                        if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                            const cellValue = cell.v.toString().trim();
                            
                            // Chercher des cellules vides, avec des espaces, ou des valeurs g√©n√©riques
                            if ((cellValue === '' || cellValue === ' ' || cellValue === 'Ville' || 
                                 cellValue === 'ville' || cellValue === 'City' || cellValue === 'city' ||
                                 cellValue.match(/^ville\s*\d*$/i) || cellValue.match(/^city\s*\d*$/i)) &&
                                labelIndex < cityNames.length) {
                                
                                const oldLabel = cell.v;
                                cell.v = cityNames[labelIndex];
                                addLog(`        üèôÔ∏è Label ${cellRef}: "${oldLabel}" ‚Üí "${cell.v}" (cellule g√©n√©rique)`, 'success');
                                labelIndex++;
                                modified = true;
                            }
                        }
                    }
                }
                
                // STRAT√âGIE 3: Modifier les valeurs num√©riques (comme avant)
                addLog(`      üìä Modification des valeurs num√©riques...`, 'info');
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'number' && cell.v > 0 && cell.v < 1) {
                        // C'est une valeur d√©cimale (probablement une donn√©e de graphique)
                        if (valueIndex < values.length) {
                            const oldValue = cell.v;
                            cell.v = values[valueIndex];
                            addLog(`        üìä Valeur ${cellRef}: ${oldValue} ‚Üí ${cell.v} (${(cell.v * 100).toFixed(1)}%)`, 'success');
                            valueIndex++;
                            modified = true;
                        }
                    }
                }
                
                if (modified) {
                    addLog(`      ‚úÖ ${valueIndex} valeurs et ${labelIndex} labels modifi√©s dans la feuille Excel`, 'success');
                } else {
                    addLog(`      ‚ö†Ô∏è Aucune valeur ou label modifi√© dans la feuille Excel`, 'warning');
                    addLog(`      üí° Conseil: V√©rifiez la structure du fichier Excel embarqu√© dans PowerPoint`, 'info');
                }
                
                return modified;
                
            } catch (error) {
                addLog(`      ‚ùå Erreur mise √† jour feuille Excel: ${error.message}`, 'error');
                return false;
            }
        }

        // Fonction pour traiter les graphiques dans les slides (fallback)
        async function processChartsInSlides(zip, templateData, row = null, excelData = null) {
            try {
                addLog('üìä RECHERCHE DES GRAPHIQUES DANS LES SLIDES', 'info');
                
                const slideFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                        slideFiles.push(relativePath);
                    }
                });
                
                addLog(`üìã ${slideFiles.length} slides √† analyser`, 'info');
                
                let graphiquesTrouves = 0;
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zip.file(slideFile).async('string');
                        
                        if (slideContent.includes('GRAPH_AGE') || slideContent.includes('GRAPH_CSP') || slideContent.includes('GRAPH_PROV')) {
                            addLog(`  ‚úÖ Graphiques trouv√©s dans ${slideFile}`, 'success');
                            
                            // Traitement sp√©cial pour GRAPH_PROV dans les slides
                            if (slideContent.includes('GRAPH_PROV')) {
                                addLog(`  üèòÔ∏è TRAITEMENT GRAPH_PROV dans ${slideFile} (XML uniquement)`, 'info');
                                
                                // APPROCHE XML UNIQUEMENT: Modifier directement le contenu XML de la slide
                                addLog(`  üîÑ Modification XML de la slide pour GRAPH_PROV...`, 'info');
                                const modifiedContent = await processChartXmlContent(slideContent, templateData, row, excelData);
                                
                                if (modifiedContent !== slideContent) {
                                    zip.file(slideFile, modifiedContent);
                                    addLog(`  ‚úÖ Slide GRAPH_PROV modifi√©e (XML): ${slideFile}`, 'success');
                                    graphiquesTrouves++;
                                } else {
                                    addLog(`  ‚ö†Ô∏è Aucune modification XML pour GRAPH_PROV dans ${slideFile}`, 'warning');
                                }
                            } else {
                                // Traitement normal pour les autres graphiques
                                const modifiedContent = await processChartXmlContent(slideContent, templateData, row, excelData);
                                
                                if (modifiedContent !== slideContent) {
                                    zip.file(slideFile, modifiedContent);
                                    addLog(`  ‚úÖ Slide modifi√©e: ${slideFile}`, 'success');
                                    graphiquesTrouves++;
                                }
                            }
                        }
                    } catch (error) {
                        addLog(`  ‚ö†Ô∏è Erreur slide ${slideFile}: ${error.message}`, 'warning');
                    }
                }
                
                return graphiquesTrouves;
                
            } catch (error) {
                addLog(`‚ùå Erreur traitement slides: ${error.message}`, 'error');
                return 0;
            }
        }

        // Fonction pour traiter les fichiers Excel embarqu√©s (version XML)
        async function processEmbeddedExcelChart(zip, chartFile, templateData) {
            try {
                addLog(`  üìä TRAITEMENT VIA XML: ${chartFile}`, 'info');
                addLog(`  üìä Donn√©es disponibles: AGE="${templateData['AGE']}", SOCIO-PRO="${templateData['SOCIO-PRO']}", SEXE="${templateData['SEXE']}"`, 'info');
                
                // Cette fonction est maintenant g√©r√©e par processEmbeddedCharts via XML
                addLog(`  ‚úÖ Traitement XML effectu√© dans processEmbeddedCharts`, 'success');
                return true;
                
            } catch (error) {
                addLog(`  ‚ùå Erreur traitement graphique ${chartFile}: ${error.message}`, 'error');
                return false;
            }
        }

        // Fonction pour forcer la mise √† jour des graphiques dans PowerPoint
        async function forceChartRefresh(zip, chartFile) {
            try {
                addLog(`    üîÑ FORCE LA MISE √Ä JOUR DES GRAPHIQUES...`, 'info');
                
                // Parcourir les slides pour trouver les graphiques li√©s √† ce fichier Excel
                const slideFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                        slideFiles.push(relativePath);
                    }
                });
                
                addLog(`    üìã ${slideFiles.length} slides √† analyser pour forcer la mise √† jour`, 'info');
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zip.file(slideFile).async('string');
                        
                        // Chercher les r√©f√©rences √† ce fichier Excel dans la slide
                        if (slideContent.includes(chartFile) || slideContent.includes('embeddings/') || 
                            slideContent.includes('GRAPH_AGE') || slideContent.includes('GRAPH_CSP') || 
                            slideContent.includes('GRAPH_PROV')) {
                            addLog(`      üìä Graphique trouv√© dans ${slideFile}`, 'info');
                            
                            // Modifier le contenu XML pour forcer la mise √† jour
                            let modifiedSlideContent = slideContent;
                            
                            // 1. Ajouter un timestamp pour forcer la mise √† jour
                            const timestamp = Date.now();
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:chart xmlns:c="http:\/\/schemas\.openxmlformats\.org\/drawingml\/2006\/chart">/g,
                                `<c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" refresh="${timestamp}">`
                            );
                            
                            // 2. Forcer la mise √† jour des donn√©es
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:externalData r:id="[^"]*"/g,
                                `<c:externalData r:id="rId1" autoUpdate="1"`
                            );
                            
                            // 3. NOUVELLE APPROCHE: Modifier les m√©tadonn√©es du graphique
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:autoUpdate val="0"/g,
                                `<c:autoUpdate val="1"`
                            );
                            
                            // 4. Ajouter des attributs de rafra√Æchissement
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:chart>/g,
                                `<c:chart autoUpdate="1" refresh="${timestamp}">`
                            );
                            
                            // 5. Modifier les relations pour forcer le rechargement
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<Relationship Id="[^"]*" Type="http:\/\/schemas\.openxmlformats\.org\/officeDocument\/2006\/relationships\/oleObject"/g,
                                `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject"`
                            );
                            
                            if (modifiedSlideContent !== slideContent) {
                                zip.file(slideFile, modifiedSlideContent);
                                addLog(`      ‚úÖ Slide ${slideFile} mise √† jour pour forcer le rafra√Æchissement`, 'success');
                                addLog(`      üîß Timestamp ajout√©: ${timestamp}`, 'info');
                            }
                        }
                    } catch (error) {
                        addLog(`      ‚ö†Ô∏è Erreur mise √† jour slide ${slideFile}: ${error.message}`, 'warning');
                    }
                }
                
                // NOUVELLE APPROCHE: Modifier le fichier de relations
                await forceChartRelationsUpdate(zip);
                
                // NOUVELLE APPROCHE: Cr√©er un fichier de m√©tadonn√©es pour forcer le rechargement
                await createChartMetadataFile(zip);
                
                addLog(`    ‚úÖ MISE √Ä JOUR DES GRAPHIQUES FORC√âE`, 'success');
                
            } catch (error) {
                addLog(`    ‚ùå Erreur force mise √† jour graphiques: ${error.message}`, 'error');
            }
        }

        // Fonction pour forcer la mise √† jour de tous les graphiques
        async function forceAllChartsRefresh(zip) {
            try {
                addLog(`    üîÑ FORCE LA MISE √Ä JOUR DE TOUS LES GRAPHIQUES...`, 'info');
                
                // 1. Parcourir tous les fichiers de graphiques
                const chartFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('charts/chart') && relativePath.endsWith('.xml')) {
                        chartFiles.push(relativePath);
                    }
                });
                
                addLog(`    üìã ${chartFiles.length} fichiers de graphiques √† forcer`, 'info');
                
                for (const chartFile of chartFiles) {
                    try {
                        const chartContent = await zip.file(chartFile).async('string');
                        
                        // Ajouter des m√©tadonn√©es de rafra√Æchissement
                        const timestamp = Date.now();
                        let modifiedChart = chartContent;
                        
                        // Forcer la mise √† jour des m√©tadonn√©es
                        modifiedChart = modifiedChart.replace(
                            /<c:chart xmlns:c="http:\/\/schemas\.openxmlformats\.org\/drawingml\/2006\/chart">/g,
                            `<c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" refresh="${timestamp}" autoUpdate="1">`
                        );
                        
                        // Ajouter des attributs de rafra√Æchissement
                        modifiedChart = modifiedChart.replace(
                            /<c:chart>/g,
                            `<c:chart autoUpdate="1" refresh="${timestamp}">`
                        );
                        
                        if (modifiedChart !== chartContent) {
                            zip.file(chartFile, modifiedChart);
                            addLog(`      ‚úÖ Graphique ${chartFile} forc√© √† se rafra√Æchir`, 'success');
                        }
                        
                    } catch (error) {
                        addLog(`      ‚ö†Ô∏è Erreur for√ßage ${chartFile}: ${error.message}`, 'warning');
                    }
                }
                
                // 2. Forcer la mise √† jour des slides
                const slideFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                        slideFiles.push(relativePath);
                    }
                });
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zip.file(slideFile).async('string');
                        
                        if (slideContent.includes('<c:chart') || slideContent.includes('GRAPH_')) {
                            const timestamp = Date.now();
                            let modifiedSlide = slideContent;
                            
                            // Forcer la mise √† jour des graphiques dans les slides
                            modifiedSlide = modifiedSlide.replace(
                                /<c:chart xmlns:c="http:\/\/schemas\.openxmlformats\.org\/drawingml\/2006\/chart">/g,
                                `<c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" refresh="${timestamp}" autoUpdate="1">`
                            );
                            
                            if (modifiedSlide !== slideContent) {
                                zip.file(slideFile, modifiedSlide);
                                addLog(`      ‚úÖ Slide ${slideFile} forc√©e √† se rafra√Æchir`, 'success');
                            }
                        }
                        
                    } catch (error) {
                        addLog(`      ‚ö†Ô∏è Erreur for√ßage slide ${slideFile}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`    ‚úÖ MISE √Ä JOUR FORC√âE DE TOUS LES GRAPHIQUES`, 'success');
                
            } catch (error) {
                addLog(`    ‚ùå Erreur for√ßage g√©n√©ral: ${error.message}`, 'error');
            }
        }

        // Fonction pour cr√©er un fichier de m√©tadonn√©es pour forcer le rechargement
        async function createChartMetadataFile(zip) {
            try {
                addLog(`    üîÑ CR√âATION FICHIER M√âTADONN√âES...`, 'info');
                
                const timestamp = Date.now();
                const metadataContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" 
                  Target="embeddings/Microsoft_Excel_Worksheet1.xlsx" 
                  autoUpdate="1" 
                  refresh="${timestamp}"/>
    <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" 
                  Target="embeddings/Microsoft_Excel_Worksheet2.xlsx" 
                  autoUpdate="1" 
                  refresh="${timestamp}"/>
</Relationships>`;
                
                // Ajouter le fichier de m√©tadonn√©es
                zip.file('embeddings/_rels/chart_metadata.rels', metadataContent);
                addLog(`      ‚úÖ Fichier m√©tadonn√©es cr√©√© avec timestamp ${timestamp}`, 'success');
                
                // Cr√©er aussi un fichier de cache pour forcer le rechargement
                const cacheContent = `<?xml version="1.0" encoding="UTF-8"?>
<ChartCache xmlns="http://schemas.microsoft.com/office/powerpoint/2010/main">
    <LastModified>${timestamp}</LastModified>
    <AutoUpdate>true</AutoUpdate>
    <RefreshOnOpen>true</RefreshOnOpen>
</ChartCache>`;
                
                zip.file('embeddings/chart_cache.xml', cacheContent);
                addLog(`      ‚úÖ Fichier cache cr√©√©`, 'success');
                
            } catch (error) {
                addLog(`    ‚ùå Erreur cr√©ation m√©tadonn√©es: ${error.message}`, 'error');
            }
        }

        // Fonction pour forcer la mise √† jour des relations des graphiques
        async function forceChartRelationsUpdate(zip) {
            try {
                addLog(`    üîÑ FORCE LA MISE √Ä JOUR DES RELATIONS...`, 'info');
                
                // Modifier le fichier de relations des slides
                const relFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/_rels/slide') && relativePath.endsWith('.rels')) {
                        relFiles.push(relativePath);
                    }
                });
                
                addLog(`    üìã ${relFiles.length} fichiers de relations √† analyser`, 'info');
                
                for (const relFile of relFiles) {
                    try {
                        const relContent = await zip.file(relFile).async('string');
                        
                        if (relContent.includes('oleObject') || relContent.includes('embeddings/')) {
                            addLog(`      üìä Relations de graphiques trouv√©es dans ${relFile}`, 'info');
                            
                            let modifiedRelContent = relContent;
                            
                            // Modifier les relations pour forcer le rechargement
                            modifiedRelContent = modifiedRelContent.replace(
                                /<Relationship Id="[^"]*" Type="http:\/\/schemas\.openxmlformats\.org\/officeDocument\/2006\/relationships\/oleObject" Target="[^"]*"/g,
                                `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" Target="../embeddings/Microsoft_Excel_Worksheet1.xlsx"`
                            );
                            
                            if (modifiedRelContent !== relContent) {
                                zip.file(relFile, modifiedRelContent);
                                addLog(`      ‚úÖ Relations ${relFile} mises √† jour`, 'success');
                            }
                        }
                    } catch (error) {
                        addLog(`      ‚ö†Ô∏è Erreur relations ${relFile}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`    ‚úÖ RELATIONS MISE √Ä JOUR`, 'success');
                
            } catch (error) {
                addLog(`    ‚ùå Erreur mise √† jour relations: ${error.message}`, 'error');
            }
        }

        // Fonction pour formater les nombres avec des espaces
        function formatNumberWithSpaces(value) {
            try {
                const num = parseFloat(value);
                if (isNaN(num)) return '0';
                return Math.round(num).toLocaleString('fr-FR');
            } catch (error) {
                return '0';
            }
        }

        // Fonction pour cr√©er le template email
        function createEmailTemplate(row, networkName) {
            try {
                // R√©cup√©rer le template personnalis√© de l'utilisateur
                const customTemplate = document.getElementById('emailTemplateEditor').value;
                
                // R√©cup√©rer les donn√©es de la ligne
                const city = row['Ville'] || 'Ville';
                const periode = row['P√©riode'] || 'p√©riode';
                const audience = row['Audience Cible'] || '0';
                const odv = row['ODV Total'] || '0';
                const reponse = row['R√©ponse'] || '0';
                const client = row['Client'] || networkName;
                
                // Calculer le num√©ro de semaine (utiliser la fonction existante)
                const weekNumber = getCurrentWeek();
                
                // Formater les donn√©es avec le m√™me algorithme que PowerPoint
                const cityFormatted = city.toUpperCase();
                const audienceFormatted = formatNumberWithSpaces(audience);
                const odvFormatted = formatNumberWithSpaces(odv);
                const reponseFormatted = formatNumberWithSpaces(reponse);
                
                // Utiliser le m√™me formatage de date que PowerPoint
                const periodeFormatted = formatDateForEmail(periode);
                
                // Cr√©er l'objet de l'email
                const emailSubject = `Buster x ${client} - Vos rapports d'audience`;
                
                // Remplacer les variables dans le template personnalis√©
                let emailBody = customTemplate
                    .replace(/\{VILLE\}/g, cityFormatted)
                    .replace(/\{PERIODE\}/g, periodeFormatted)
                    .replace(/\{AUDIENCE\}/g, audienceFormatted)
                    .replace(/\{ODV\}/g, odvFormatted)
                    .replace(/\{REPONSE\}/g, reponseFormatted)
                    .replace(/\{WEEK\}/g, weekNumber);
                
                // Si le template est vide, utiliser le template par d√©faut
                if (!customTemplate.trim()) {
                    emailBody = `Bonjour,
Vous trouverez ci-joint le bilan complet de votre campagne men√©e sur les bus de ${cityFormatted} ${periodeFormatted}.
Durant cette p√©riode, vous avez touch√© une audience de ${audienceFormatted} personnes et votre campagne a g√©n√©r√© plus de ${odvFormatted} contacts.
Parcourez le document en pi√®ce jointe pour conna√Ætre les indicateurs cl√©s de votre campagne et le profil de votre audience.
Bien √† vous,

`;
                }
                
                 // Cr√©er le contenu du fichier .txt
                 const txtContent = `Subject: ${emailSubject}

 ${emailBody}`;
                
                 return txtContent;
                
            } catch (error) {
                addLog(`‚ùå Erreur cr√©ation template email: ${error.message}`, 'error');
                return `Bonjour,
Vous trouverez ci-joint le bilan complet de votre campagne.
Bien √† vous,

`;
            }
        }

        // Fonction pour formater les dates dans les emails (m√™me algorithme que PowerPoint)
        function formatDateForEmail(dateStr) {
            if (!dateStr) return '';
            const match = dateStr.match(/du (\d{4}-\d{2}-\d{2}) au (\d{4}-\d{2}-\d{2})/i);
            if (!match) return dateStr;
            
            const [, startDate, endDate] = match;
            
            function formatSingleDate(date) {
                const [year, month, day] = date.split('-');
                const months = [
                    'janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin',
                    'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'
                ];
                return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
            }
            
            return `du ${formatSingleDate(startDate)} au ${formatSingleDate(endDate)}`;
        }

        // Fonction supprim√©e - plus d'Excel, uniquement XML

        // ANCIENNE FONCTION SUPPRIM√âE - REMPLAC√âE PAR updateAgeChartDataDirect

        // Fonction supprim√©e - maintenant g√©r√©e par le traitement XML

        // Fonction supprim√©e - maintenant g√©r√©e par le traitement XML

        // ANCIENNES FONCTIONS SUPPRIM√âES - REMPLAC√âES PAR LES FONCTIONS Direct

        // FONCTION SUPPRIM√âE - Plus utilis√©e avec l'approche Direct

        // Gestion du bouton Documentation
        document.getElementById('docBtn').addEventListener('click', function() {
            showDocumentation();
        });

        // Gestion des fichiers s√©lectionn√©s
        document.getElementById('excelFile').addEventListener('change', function(e) {
            const label = document.getElementById('excelLabel');
            const span = label.querySelector('span');
            if (e.target.files.length > 0) {
                span.textContent = e.target.files[0].name;
                label.classList.add('has-file');
            } else {
                span.textContent = 'S√©lectionner un fichier Excel (.xlsx, .xls)';
                label.classList.remove('has-file');
            }
        });

        document.getElementById('powerpointFile').addEventListener('change', function(e) {
            const label = document.getElementById('powerpointLabel');
            const span = label.querySelector('span');
            if (e.target.files.length > 0) {
                span.textContent = e.target.files[0].name;
                label.classList.add('has-file');
            } else {
                span.textContent = 'S√©lectionner un fichier PowerPoint (.pptx, .ppt)';
                label.classList.remove('has-file');
            }
        });

        // Fonctions pour l'√©cran de chargement PowerPoint
        function showPptLoadingScreen() {
            document.getElementById('pptLoadingScreen').classList.add('active');
            document.getElementById('loadingScreen').classList.remove('active');
            document.getElementById('formContainer').classList.add('hidden');
        }

        function hidePptLoadingScreen() {
            document.getElementById('pptLoadingScreen').classList.remove('active');
            document.getElementById('formContainer').classList.remove('hidden');
        }

        function updatePptProgress(current, total, status = '') {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const pptStatus = document.getElementById('pptStatus');
            
            const percentage = total > 0 ? (current / total) * 100 : 0;
            
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${current}/${total} fichiers trait√©s`;
            
            // Calculer l'estimation du temps restant avec produit en croix
            let timeEstimation = '';
            if (current > 0 && total > current && processingStartTime) {
                const elapsed = Date.now() - processingStartTime;
                const avgTimePerFile = elapsed / current;
                const remainingFiles = total - current;
                const estimatedRemainingMs = remainingFiles * avgTimePerFile;
                timeEstimation = `Temps restant estim√© : ${formatTime(estimatedRemainingMs)}`;
            } else if (current === total) {
                timeEstimation = 'Finalisation en cours...';
            } else {
                timeEstimation = 'Calcul en cours...';
            }
            
            if (pptStatus) {
                pptStatus.textContent = timeEstimation;
            }
            
            if (current > 0 && current < total) {
                progressBar.style.boxShadow = `0 0 15px rgba(162, 19, 123, 0.7)`;
                setTimeout(() => {
                    progressBar.style.boxShadow = `0 0 10px rgba(162, 19, 123, 0.5)`;
                }, 300);
            }
        }

        async function processFilesLocally(excelFile, powerpointFile, outputPrefix, emailDestination, emailTemplate = null, chartData = null) {
            try {
                addLog('D√©but du traitement local des fichiers', 'info');
                addLog(`Excel: ${excelFile.name}`, 'info');
                addLog(`PowerPoint: ${powerpointFile.name}`, 'info');
                addLog(`Email destination: ${emailDestination}`, 'info');
                
                showPptLoadingScreen();

                // 1. Lire le fichier Excel
                addLog('Lecture du fichier Excel...', 'info');
                const excelData = await readExcelFile(excelFile);
                
                // 2. Trouver la sheet "Performance m√©dia"
                const performanceSheet = excelData.Sheets['Performance m√©dia'];
                if (!performanceSheet) {
                    throw new Error('Sheet "Performance m√©dia" non trouv√©e dans le fichier Excel');
                }

                // 3. Convertir en JSON pour traitement
                const jsonData = XLSX.utils.sheet_to_json(performanceSheet);
                addLog('Sheet "Performance m√©dia" trouv√©e', 'success');
                addLog(`${jsonData.length} lignes trouv√©es dans Performance m√©dia`, 'info');

                // 4. Limiter √† 3 lignes pour le debug
                const maxRows = Math.min(3, jsonData.length); // Limiter √† 3 lignes pour le debug
                initializeTimeEstimation(maxRows);
                addLog(`üîß DEBUG: Traitement limit√© √† ${maxRows} lignes (mode debug)`, 'warning');
                addLog(`Estimation du temps initialis√©e pour ${maxRows} fichiers`, 'info');
                
                if (jsonData.length > 0) {
                    const columns = Object.keys(jsonData[0]);
                    addLog(`Colonnes disponibles: ${columns.join(', ')}`, 'info');
                }

                // 4. Lire la sheet "Audience" pour les donn√©es d√©mographiques
                const audienceSheet = excelData.Sheets['Audience'];
                if (audienceSheet) {
                    addLog('‚úÖ Sheet "Audience" trouv√©e', 'success');
                } else {
                    addLog('‚ö†Ô∏è Sheet "Audience" non trouv√©e - les donn√©es d√©mographiques ne seront pas disponibles', 'warning');
                }


                // 5. Lire le fichier PowerPoint template
                addLog('üìñ Lecture du fichier PowerPoint template...', 'info');
                
                if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip n\'est pas charg√©. V√©rifiez la connexion internet.');
                }
                
                const templateArrayBuffer = await powerpointFile.arrayBuffer();
                addLog('Template PowerPoint lu', 'success');

                // 6. Traiter les 3 premi√®res lignes (debug) - maxRows d√©j√† d√©fini plus haut
                addLog(`Traitement des ${maxRows} premi√®res lignes (mode debug)...`, 'info');

                updatePptProgress(0, maxRows, 'Pr√©paration des donn√©es...');

                const results = [];
                const allFiles = []; // Collecter tous les fichiers pour le ZIP final

                for (let i = 0; i < maxRows; i++) {
                    currentRow = i + 1; // Mettre √† jour le compteur global
                    const row = jsonData[i];
                    const networkName = row['r√©seau'] || row['R√©seau'] || `ligne_${i + 1}`;
                    addLog(`Traitement ligne ${i + 1}: ${networkName}`, 'info');
                    
                    updatePptProgress(i, maxRows);

                    try {
                        addLog(`  Traitement du template pour ligne ${i + 1}`, 'info');
                        
                        const zip = await JSZip.loadAsync(templateArrayBuffer);
                        
                        // Mapping des donn√©es avec formatage
                        const mapping = {
                            'ODV Total': 'ODV',
                            'GRP': 'GRP',
                            'R√©petition Cible': 'TIMES',
                            'ODV Cible': 'VIEWS',
                            'Couverture Cible': 'POP',
                            'P√©riode': 'DATE',
                            'Ville': 'CITY',
                            'Audience Cible': 'AUDIENCE',
                            'Client': 'CLIENT',
                            'WEEK': 'WEEK'
                        };

                        // Fonctions de formatage
                        function formatNumber(value, type) {
                            if (!value && value !== 0) return '';
                            const num = parseFloat(value);
                            if (isNaN(num)) return value;
                            
                            function addSpaces(number) {
                                return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
                            }
                            
                            switch(type) {
                                case 'ROUND_UP':
                                    return addSpaces(Math.ceil(num));
                                case 'ONE_DECIMAL':
                                    const decimal = num.toFixed(1);
                                    const [integer, fraction] = decimal.split('.');
                                    return addSpaces(integer) + '.' + fraction;
                                case 'TWO_DECIMALS_COMMA':
                                    const decimal2 = num.toFixed(2);
                                    const [integer2, fraction2] = decimal2.split('.');
                                    return addSpaces(integer2) + ',' + fraction2;
                                case 'PERCENTAGE':
                                    return addSpaces((num * 100).toFixed(0)) + '%';
                                default:
                                    return value;
                            }
                        }
                        
                        function formatDate(dateStr) {
                            if (!dateStr) return '';
                            const match = dateStr.match(/du (\d{4}-\d{2}-\d{2}) au (\d{4}-\d{2}-\d{2})/i);
                            if (!match) return dateStr;
                            
                            const [, startDate, endDate] = match;
                            
                            function formatSingleDate(date) {
                                const [year, month, day] = date.split('-');
                                const months = [
                                    'janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin',
                                    'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre'
                                ];
                                return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
                            }
                            
                            return `du ${formatSingleDate(startDate)} au ${formatSingleDate(endDate)}`;
                        }

                        // Pr√©parer les donn√©es pour le remplacement
                        const templateData = {};
                        let replacementsCount = 0;
                        
                        // Calculer le num√©ro de semaine actuelle
                        const weekNumber = getCurrentWeek();
                        templateData['WEEK'] = weekNumber;
                        addLog(`    üìÖ Num√©ro de semaine calcul√©: ${weekNumber}`, 'info');
                        
                        
                        for (const [excelColumn, templateKey] of Object.entries(mapping)) {
                            let value;
                            let formattedValue;
                            
                            // Traitement sp√©cial pour WEEK (variable calcul√©e)
                            if (templateKey === 'WEEK') {
                                value = weekNumber;
                                formattedValue = value.toString();
                                addLog(`    üìÖ Variable WEEK calcul√©e: ${value}`, 'info');
                            } else if (row[excelColumn] !== undefined && row[excelColumn] !== null) {
                                value = row[excelColumn];
                                
                                switch(templateKey) {
                                    case 'ODV': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    case 'GRP': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    case 'TIMES': formattedValue = formatNumber(value, 'TWO_DECIMALS_COMMA'); break;
                                    case 'VIEWS': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    case 'POP': formattedValue = formatNumber(value, 'PERCENTAGE'); break;
                                    case 'DATE': formattedValue = formatDate(value); break;
                                    case 'CITY': formattedValue = String(value).toUpperCase(); break;
                                    case 'AUDIENCE': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    default: formattedValue = String(value);
                                }
                                
                                templateData[templateKey] = formattedValue;
                                addLog(`    üîÑ ${excelColumn} ‚Üí {${templateKey}} = ${formattedValue}`, 'info');
                                replacementsCount++;
                            } else if (templateKey !== 'WEEK') {
                                templateData[templateKey] = '';
                                addLog(`    ‚ö†Ô∏è Colonne "${excelColumn}" non trouv√©e pour {${templateKey}}`, 'warning');
                            }
                        }
                        
                        // S'assurer que WEEK est bien dans templateData
                        if (!templateData['WEEK']) {
                            templateData['WEEK'] = weekNumber;
                            addLog(`    üìÖ WEEK ajout√© au templateData: ${weekNumber}`, 'info');
                        }

                        // Utiliser les donn√©es saisies par l'utilisateur pour les graphiques
                        if (chartData) {
                            addLog(`  üìä Utilisation des donn√©es saisies par l'utilisateur...`, 'info');
                            
                            // Utiliser les donn√©es des graphiques saisies par l'utilisateur
                            if (chartData['AGE']) {
                                templateData['AGE'] = chartData['AGE'];
                                addLog(`    ‚úÖ Donn√©es AGE utilisateur: "${templateData['AGE']}"`, 'success');
                            }
                            
                            if (chartData['SOCIO-PRO']) {
                                templateData['SOCIO-PRO'] = chartData['SOCIO-PRO'];
                                addLog(`    ‚úÖ Donn√©es CSP utilisateur: "${templateData['SOCIO-PRO']}"`, 'success');
                            }
                            
                            if (chartData['SEXE']) {
                                templateData['SEXE'] = chartData['SEXE'];
                                addLog(`    ‚úÖ Donn√©es SEXE utilisateur: "${templateData['SEXE']}"`, 'success');
                            }
                            
                            
                        } else if (audienceSheet) {
                            addLog(`  üìä Lecture des donn√©es d√©mographiques depuis Excel...`, 'info');
                            
                            const currentPeriod = row['P√©riode'];
                            let audienceRowIndex = -1;
                            
                            for (let audienceRow = 2; audienceRow <= 100; audienceRow++) {
                                const audienceDateCell = audienceSheet[`A${audienceRow}`];
                                if (audienceDateCell && audienceDateCell.v === currentPeriod) {
                                    audienceRowIndex = audienceRow;
                                    addLog(`  ‚úÖ Ligne Audience trouv√©e: ${audienceRow}`, 'success');
                                    break;
                                }
                            }
                            
                            if (audienceRowIndex !== -1) {
                                // CORRECTION: Donn√©es AGE (colonnes C √† G) - VRAIES DONN√âES AGE
                                const ageColumns = ['C', 'D', 'E', 'F', 'G'];
                                const ageLabels = ['15-24 ans', '25-34 ans', '35-49 ans', '50-64 ans', '65 ans ou plus'];
                                const ageData = [];
                                
                                addLog(`    üìä MAPPING DONN√âES AGE R√âELLES depuis Audience ligne ${audienceRowIndex}`, 'info');
                                addLog(`    üîç Colonnes AGE utilis√©es: ${ageColumns.join(', ')}`, 'info');
                                for (let j = 0; j < ageColumns.length; j++) {
                                    const cellRef = `${ageColumns[j]}${audienceRowIndex}`;
                                    const cell = audienceSheet[cellRef];
                                    if (cell && cell.v !== undefined) {
                                        // V√©rifier si la valeur est d√©j√† en pourcentage ou en d√©cimal
                                        const cellValue = cell.v;
                                        const percentageValue = cellValue > 1 ? cellValue.toFixed(1) : (cellValue * 100).toFixed(1);
                                        ageData.push(`${ageLabels[j]}: ${percentageValue}%`);
                                        addLog(`      üìä ${ageLabels[j]}: ${percentageValue}% (cellule ${cellRef})`, 'info');
                                    } else {
                                        addLog(`      ‚ùå Cellule ${cellRef} vide ou invalide`, 'warning');
                                    }
                                }
                                templateData['AGE'] = ageData.join(', ');
                                addLog(`    ‚úÖ Donn√©es AGE finales: "${templateData['AGE']}"`, 'success');
                                
                                // CORRECTION: Donn√©es CSP (colonnes H √† P) - VRAIES DONN√âES CSP
                                const cspColumns = ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'];
                                const cspLabels = ['Agriculteurs', 'Artisans', 'Autres', 'Cadres', '√âtudiants', 'Employ√©s', 'Ouvriers', 'Professions interm√©diaires', 'Retrait√©s'];
                                const cspData = [];
                                
                                addLog(`    üìä MAPPING DONN√âES CSP R√âELLES depuis Audience ligne ${audienceRowIndex}`, 'info');
                                addLog(`    üîç Colonnes CSP utilis√©es: ${cspColumns.join(', ')}`, 'info');
                                for (let j = 0; j < cspColumns.length; j++) {
                                    const cellRef = `${cspColumns[j]}${audienceRowIndex}`;
                                    const cell = audienceSheet[cellRef];
                                    if (cell && cell.v !== undefined) {
                                        // V√©rifier si la valeur est d√©j√† en pourcentage ou en d√©cimal
                                        const cellValue = cell.v;
                                        const percentageValue = cellValue > 1 ? cellValue.toFixed(1) : (cellValue * 100).toFixed(1);
                                        cspData.push(`${cspLabels[j]}: ${percentageValue}%`);
                                        addLog(`      üìä ${cspLabels[j]}: ${percentageValue}% (cellule ${cellRef})`, 'info');
                                    } else {
                                        addLog(`      ‚ùå Cellule ${cellRef} vide ou invalide`, 'warning');
                                    }
                                }
                                templateData['SOCIO-PRO'] = cspData.join(', ');
                                addLog(`    ‚úÖ Donn√©es CSP finales: "${templateData['SOCIO-PRO']}"`, 'success');
                                
                                // Donn√©es SEXE (colonnes Q et R)
                                const menCell = audienceSheet[`Q${audienceRowIndex}`];
                                const womenCell = audienceSheet[`R${audienceRowIndex}`];
                                
                                addLog(`    üìä MAPPING DONN√âES SEXE depuis Audience ligne ${audienceRowIndex}`, 'info');
                                if (menCell && womenCell && menCell.v !== undefined && womenCell.v !== undefined) {
                                    // V√©rifier si les valeurs sont d√©j√† en pourcentage ou en d√©cimal
                                    const menValue = menCell.v;
                                    const womenValue = womenCell.v;
                                    
                                    // Si la valeur est > 1, elle est d√©j√† en pourcentage, sinon c'est un d√©cimal
                                    const menPercentage = menValue > 1 ? menValue.toFixed(1) : (menValue * 100).toFixed(1);
                                    const womenPercentage = womenValue > 1 ? womenValue.toFixed(1) : (womenValue * 100).toFixed(1);
                                    templateData['SEXE'] = `Homme: ${menPercentage}%, Femme: ${womenPercentage}%`;
                                    templateData['MEN'] = `${menPercentage}%`;
                                    templateData['WOMEN'] = `${womenPercentage}%`;
                                    addLog(`      üìä Homme: ${menPercentage}% (cellule Q${audienceRowIndex})`, 'info');
                                    addLog(`      üìä Femme: ${womenPercentage}% (cellule R${audienceRowIndex})`, 'info');
                                    addLog(`    ‚úÖ Donn√©es SEXE finales: "${templateData['SEXE']}"`, 'success');
                                }
                            }
                        }

                        // Traiter les slides pour les remplacements de texte
                        const slideFiles = [];
                        zip.forEach((relativePath, file) => {
                            if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                                slideFiles.push(relativePath);
                            }
                        });
                        
                        addLog(`  üìä ${slideFiles.length} slides trouv√©es`, 'info');
                        
                        // DEBUG: Afficher toutes les variables disponibles
                        addLog(`  üîç DEBUG: Variables disponibles dans templateData:`, 'info');
                        for (const [key, value] of Object.entries(templateData)) {
                            addLog(`    üîç ${key}: ${value}`, 'info');
                        }
                        
                        // Nouvelle logique simplifi√©e pour les pages de garde
                        const networkDataForCover = parseNetworkData(networkName);
                        const faceType = networkDataForCover.face ? networkDataForCover.face.toLowerCase() : '';
                        const cityName = networkDataForCover.ville ? networkDataForCover.ville.toLowerCase() : '';
                        const isFlancGauche = faceType.includes('gauche');
                        const isFlancDroit = faceType.includes('droit');
                        const isArriere = faceType.includes('arri√®re') || faceType.includes('arriere');
                        const isBrest = cityName.includes('brest');
                        const isBrestFlancDroit = isBrest && isFlancDroit;
                        
                        addLog(`      üìÑ Type de flanc d√©tect√©: ${networkDataForCover.face}`, 'info');
                        addLog(`      üèôÔ∏è Ville d√©tect√©e: ${networkDataForCover.ville}`, 'info');
                        if (isBrestFlancDroit) {
                            addLog(`      ‚≠ê R√®gle sp√©ciale Brest + Flanc Droit activ√©e`, 'info');
                        }
                        
                        // Traiter toutes les slides avec masquage au lieu de suppression
                        for (const slideFile of slideFiles) {
                            const content = await zip.file(slideFile).async('string');
                            let modifiedContent = content;
                            
                            // D√©terminer si cette slide doit √™tre masqu√©e
                            let shouldHide = false;
                            let hideReason = '';
                            
                            // R√®gles de masquage existantes (diapos 1 et 2)
                            if (slideFile.includes('slide1.xml') && isFlancGauche) {
                                shouldHide = true;
                                hideReason = 'Slide 1 masqu√©e (Flanc Gauche)';
                            } else if (slideFile.includes('slide2.xml') && !isFlancGauche) {
                                shouldHide = true;
                                hideReason = 'Slide 2 masqu√©e (Flanc Droit/Arri√®re)';
                            }
                            
                            // Nouvelles r√®gles de masquage
                            if (slideFile.includes('slide5.xml')) {
                                if (isBrestFlancDroit) {
                                    // R√®gle sp√©ciale Brest : masquer slide 5 si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 5 masqu√©e (Brest + Flanc Droit)';
                                } else if (isFlancDroit || isArriere) {
                                    shouldHide = true;
                                    hideReason = 'Slide 5 masqu√©e (Flanc Droit/Arri√®re)';
                                }
                            } else if (slideFile.includes('slide6.xml')) {
                                if (isBrestFlancDroit) {
                                    // R√®gle sp√©ciale Brest : masquer slide 6 si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 6 masqu√©e (Brest + Flanc Droit)';
                                } else if (isFlancGauche || isFlancDroit) {
                                    shouldHide = true;
                                    hideReason = 'Slide 6 masqu√©e (Flanc Gauche/Droit)';
                                }
                            } else if (slideFile.includes('slide7.xml')) {
                                if (isBrestFlancDroit) {
                                    // R√®gle sp√©ciale Brest : masquer slide 7 si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 7 masqu√©e (Brest + Flanc Droit)';
                                } else if (isFlancGauche || isArriere) {
                                    shouldHide = true;
                                    hideReason = 'Slide 7 masqu√©e (Flanc Gauche/Arri√®re)';
                                }
                            } else if (slideFile.includes('slide8.xml')) {
                                if (!isBrestFlancDroit) {
                                    // R√®gle sp√©ciale Brest : masquer slide 8 sauf si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 8 masqu√©e (Non Brest ou Non Flanc Droit)';
                                } else {
                                    addLog(`      ‚úÖ Slide 8 affich√©e (Brest + Flanc Droit)`, 'success');
                                }
                            }
                            
                            if (shouldHide) {
                                addLog(`      üëÅÔ∏è ${hideReason}`, 'info');
                            }
                            
                            // D√©sactiver visuellement la slide dans l'√©diteur
                            if (shouldHide) {
                                // M√©thode 1: Ajouter show="0" pour masquer la slide
                                modifiedContent = modifiedContent.replace(
                                    /<p:sld[^>]*>/g, 
                                    (match) => {
                                        if (!match.includes('show=')) {
                                            return match.replace('>', ' show="0">');
                                        }
                                        return match;
                                    }
                                );
                                
                                // M√©thode 2: Ajouter hidden="1" pour la d√©sactiver compl√®tement
                                modifiedContent = modifiedContent.replace(
                                    /<p:sld[^>]*>/g,
                                    (match) => {
                                        if (!match.includes('hidden=')) {
                                            return match.replace('>', ' hidden="1">');
                                        }
                                        return match;
                                    }
                                );
                                
                                // M√©thode 3: Modifier le type de slide pour la rendre invisible
                                modifiedContent = modifiedContent.replace(
                                    /<p:sldId[^>]*>/g,
                                    (match) => {
                                        if (!match.includes('show=')) {
                                            return match.replace('>', ' show="0" hidden="1">');
                                        }
                                        return match;
                                    }
                                );
                                
                                addLog(`      üîß Slide d√©sactiv√©e visuellement dans ${slideFile}`, 'info');
                                addLog(`      üîß Attributs ajout√©s: show="0" hidden="1"`, 'info');
                            }
                            
                            // Traiter les variables pour toutes les slides
                            for (const [templateKey, value] of Object.entries(templateData)) {
                                const placeholder = `{${templateKey}}`;
                                if (modifiedContent.includes(placeholder)) {
                                    modifiedContent = modifiedContent.replace(new RegExp(placeholder, 'g'), value);
                                    addLog(`      üîÑ Remplac√© ${placeholder} par ${value}`, 'info');
                                }
                            }
                            
                            zip.file(slideFile, modifiedContent);
                            addLog(`      ‚úÖ Slide trait√©e: ${slideFile}`, 'success');
                        }
                        
                        // D√©sactiver les slides dans presentation.xml pour qu'elles n'apparaissent pas dans l'√©diteur
                        try {
                            const presentationContent = await zip.file('ppt/presentation.xml').async('string');
                            let modifiedPresentation = presentationContent;
                            
                            // D√©sactiver slide 1 si flanc gauche
                            if (isFlancGauche) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId1"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 1 d√©sactiv√©e dans presentation.xml (Flanc Gauche)`, 'info');
                            }
                            
                            // D√©sactiver slide 2 si flanc droit ou arri√®re
                            if (!isFlancGauche) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId2"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 2 d√©sactiv√©e dans presentation.xml (Flanc Droit/Arri√®re)`, 'info');
                            }
                            
                            // D√©sactiver slide 5 selon les r√®gles
                            if (isBrestFlancDroit) {
                                // R√®gle sp√©ciale Brest : d√©sactiver slide 5 si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId5"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 5 d√©sactiv√©e dans presentation.xml (Brest + Flanc Droit)`, 'info');
                            } else if (isFlancDroit || isArriere) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId5"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 5 d√©sactiv√©e dans presentation.xml (Flanc Droit/Arri√®re)`, 'info');
                            }
                            
                            // D√©sactiver slide 6 selon les r√®gles
                            if (isBrestFlancDroit) {
                                // R√®gle sp√©ciale Brest : d√©sactiver slide 6 si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId6"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 6 d√©sactiv√©e dans presentation.xml (Brest + Flanc Droit)`, 'info');
                            } else if (isFlancGauche || isFlancDroit) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId6"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 6 d√©sactiv√©e dans presentation.xml (Flanc Gauche/Droit)`, 'info');
                            }
                            
                            // D√©sactiver slide 7 selon les r√®gles
                            if (isBrestFlancDroit) {
                                // R√®gle sp√©ciale Brest : d√©sactiver slide 7 si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId7"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 7 d√©sactiv√©e dans presentation.xml (Brest + Flanc Droit)`, 'info');
                            } else if (isFlancGauche || isArriere) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId7"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 7 d√©sactiv√©e dans presentation.xml (Flanc Gauche/Arri√®re)`, 'info');
                            }
                            
                            // D√©sactiver slide 8 selon la r√®gle sp√©ciale Brest
                            if (!isBrestFlancDroit) {
                                // Masquer slide 8 sauf si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId8"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      üîß Slide 8 d√©sactiv√©e dans presentation.xml (Non Brest ou Non Flanc Droit)`, 'info');
                            } else {
                                addLog(`      ‚úÖ Slide 8 activ√©e dans presentation.xml (Brest + Flanc Droit)`, 'success');
                            }
                            
                            if (modifiedPresentation !== presentationContent) {
                                zip.file('ppt/presentation.xml', modifiedPresentation);
                                addLog(`      ‚úÖ presentation.xml modifi√© pour d√©sactiver les slides`, 'success');
                            }
                        } catch (error) {
                            addLog(`      ‚ö†Ô∏è Erreur modification presentation.xml: ${error.message}`, 'warning');
                        }

                        // Traiter les graphiques Excel embarqu√©s
                        const chartsProcessed = await processEmbeddedCharts(zip, templateData, row, excelData);
                        addLog(`  üìà ${chartsProcessed} graphiques trait√©s`, 'info');
                        
                        // NOUVELLE APPROCHE: Forcer la mise √† jour de tous les graphiques
                        if (chartsProcessed > 0) {
                            addLog(`  üîÑ FORCE LA MISE √Ä JOUR DE TOUS LES GRAPHIQUES...`, 'info');
                            await forceAllChartsRefresh(zip);
                        }
                        
                        // G√©n√©rer le fichier PowerPoint
                        const blob = await zip.generateAsync({
                            type: "blob",
                            compression: "STORE", // Pas de compression pour √©viter la corruption
                            compressionOptions: { level: 0 }
                        });

                        // Validation du fichier g√©n√©r√©
                        if (!blob || blob.size === 0) {
                            throw new Error(`Fichier PowerPoint vide g√©n√©r√© pour ${networkName}`);
                        }
                        
                        addLog(`  ‚úÖ Fichier PowerPoint g√©n√©r√©: ${(blob.size / 1024 / 1024).toFixed(2)} MB`, 'success');

                        // G√©n√©rer le nom de fichier selon la nouvelle nomenclature
                        // Format: "Buster x [ville] - [flanc] - [ville] - S[numero_semaine].pptx"
                        const networkData = parseNetworkData(networkName);
                        const city = networkData.ville || row['Ville'] || 'Inconnue';
                        const flanc = networkData.face || 'Inconnu';
                        const currentWeek = getCurrentWeek();
                        const fileName = `Buster x ${city} - ${flanc} - ${city} - S${currentWeek}.pptx`;
                        
                        addLog(`  üìä Donn√©es r√©seau pars√©es: ${JSON.stringify(networkData)}`, 'info');
                        
                        // Cr√©er le chemin de fichier avec la hi√©rarchie
                        const filePath = createFileHierarchy(networkData, fileName);
                        
                        // Collecter le fichier pour le ZIP avec la hi√©rarchie
                        allFiles.push({
                            name: filePath,
                            blob: blob,
                            type: 'pptx',
                            networkData: networkData
                        });
                        
                        
                         // Cr√©er le fichier template email avec extension .txt
                         const emailTemplate = createEmailTemplate(row, networkName);
                         const msgFileName = `Template email - ${fileName.replace('.pptx', '.txt')}`;
                         const msgFilePath = createFileHierarchy(networkData, msgFileName);
                         const msgBlob = new Blob([emailTemplate], { type: 'text/plain;charset=utf-8' });
                        
                         // Collecter le fichier email pour le ZIP final avec la hi√©rarchie
                         allFiles.push({
                             name: msgFilePath,
                             blob: msgBlob,
                             type: 'txt',
                             networkData: networkData
                         });
                        
                        addLog(`  üìß Template email g√©n√©r√©: ${msgFileName}`, 'info');
                        
                        results.push({
                            fileName: fileName,
                            network: networkName,
                            replacements: replacementsCount,
                            charts: chartsProcessed,
                            row: i + 1
                        });

                        addLog(`  ‚úÖ Fichier cr√©√©: ${fileName}`, 'success');
                        addLog(`  ‚úÖ Template email cr√©√©: ${msgFileName}`, 'success');
                        updatePptProgress(i + 1, maxRows);
                        
                    } catch (error) {
                        addLog(`  ‚ùå Erreur ligne ${i + 1}: ${error.message}`, 'error');
                        updatePptProgress(i + 1, maxRows);
                    }
                }
                
                updatePptProgress(maxRows, maxRows);

                // Cr√©er le ZIP final avec tous les fichiers
                if (allFiles.length > 0) {
                    addLog(`üì¶ Cr√©ation du dossier ZIP avec ${allFiles.length} fichiers...`, 'info');
                    
                    try {
                        // Cr√©er un nouveau ZIP pour contenir tous les fichiers
                        const finalZip = new JSZip();
                        
                        // Ajouter tous les fichiers au ZIP
                        for (const file of allFiles) {
                            finalZip.file(file.name, file.blob);
                        }
                        
                        // G√©n√©rer le ZIP final
                        const finalZipBlob = await finalZip.generateAsync({
                            type: "blob",
                            compression: "STORE", // Pas de compression pour √©viter la corruption
                            compressionOptions: { level: 0 }
                        });
                        
                        // Validation du ZIP final
                        if (!finalZipBlob || finalZipBlob.size === 0) {
                            throw new Error('ZIP final vide g√©n√©r√©');
                        }
                        
                        addLog(`‚úÖ ZIP final g√©n√©r√©: ${(finalZipBlob.size / 1024 / 1024).toFixed(2)} MB`, 'success');
                        
                        // Envoyer le ZIP vers le webhook Taskalys avec le bon nom
                        const currentYear = new Date().getFullYear();
                        const zipFileName = `${currentYear} - rapports d'audience.zip`;
                        addLog(`üì¶ Envoi du dossier ZIP vers Taskalys: ${zipFileName}`, 'success');
                        
                        try {
                            // Cr√©er FormData pour l'envoi
                            const formData = new FormData();
                            formData.append('file', finalZipBlob, zipFileName);
                            formData.append('timestamp', new Date().toISOString());
                            formData.append('totalFiles', allFiles.length.toString());
                            formData.append('email', emailDestination);
                            addLog(`üìß Email de destination inclus: ${emailDestination}`, 'info');
                            
                            // Envoyer vers le webhook
                            const response = await fetch('https://host.taskalys.app/webhook/buster', {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const result = await response.text();
                                addLog(`‚úÖ ZIP envoy√© avec succ√®s vers Taskalys`, 'success');
                                addLog(`üìã R√©ponse du serveur: ${result}`, 'info');
                            } else {
                                addLog(`‚ùå Erreur envoi ZIP: ${response.status} ${response.statusText}`, 'error');
                            }
                            
                        } catch (error) {
                            addLog(`‚ùå Erreur envoi vers Taskalys: ${error.message}`, 'error');
                            
                            // Solution de secours : t√©l√©chargement local pour test
                            addLog(`üîÑ T√©l√©chargement local comme solution de secours...`, 'warning');
                            
                            try {
                                const downloadLink = document.createElement('a');
                                downloadLink.href = URL.createObjectURL(finalZipBlob);
                                downloadLink.download = zipFileName;
                                downloadLink.click();
                                addLog(`‚úÖ Fichier ZIP t√©l√©charg√© localement: ${zipFileName}`, 'success');
                                addLog(`üí° Vous pouvez maintenant tester l'ouverture des fichiers PowerPoint`, 'info');
                            } catch (downloadError) {
                                addLog(`‚ùå Erreur t√©l√©chargement local: ${downloadError.message}`, 'error');
                                throw new Error(`√âchec complet: API + T√©l√©chargement local`);
                            }
                        }
                        
                        addLog(`‚úÖ ${allFiles.length} fichiers envoy√©s dans le dossier ZIP vers Taskalys`, 'success');
                        
                        // Afficher des informations sur l'envoi vers Taskalys
                        addLog(`üì° Les fichiers ont √©t√© envoy√©s vers le serveur Taskalys`, 'info');
                        addLog(`üìß Consultez vos emails pour recevoir les rapports d'audience`, 'success');
                        addLog(`üîó Webhook: https://host.taskalys.app/webhook-test/buster`, 'info');
                        
                        // Arr√™ter l'estimation du temps
                        stopTimeEstimation();
                        
                    } catch (error) {
                        addLog(`‚ùå Erreur cr√©ation ZIP: ${error.message}`, 'error');
                    }
                }

                setTimeout(() => {
                    hidePptLoadingScreen();
                }, 2000);

                return {
                    success: true,
                    processed: results.length,
                    results: results,
                    totalRows: jsonData.length,
                    totalFiles: allFiles.length
                };

            } catch (error) {
                addLog(`‚ùå Erreur lors du traitement: ${error.message}`, 'error');
                stopTimeEstimation(); // Arr√™ter l'estimation du temps en cas d'erreur
                hidePptLoadingScreen();
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Fonction pour lire un fichier Excel
        function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        resolve(workbook);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Erreur lors de la lecture du fichier Excel'));
                reader.readAsArrayBuffer(file);
            });
        }

        // Variables pour l'estimation du temps
        let processingStartTime = null;
        let totalRowsToProcess = 0;
        let currentRow = 0;
        let estimatedTimePerFile = 15000; // 15 secondes par fichier en moyenne
        let timeEstimationInterval = null;

        // Fonctions pour l'estimation du temps
        function initializeTimeEstimation(totalRows) {
            totalRowsToProcess = totalRows;
            processingStartTime = Date.now();
            
            // Mettre √† jour l'affichage initial
            updateTimeEstimation(0);
            
            // D√©marrer l'intervalle de mise √† jour
            timeEstimationInterval = setInterval(() => {
                updateTimeEstimation(currentRow);
            }, 1000);
        }

        function updateTimeEstimation(processedRows) {
            const timeRemainingValue = document.getElementById('timeRemainingValue');
            const processedCount = document.getElementById('processedCount');
            const totalCount = document.getElementById('totalCount');
            
            if (timeRemainingValue && processedCount && totalCount) {
                processedCount.textContent = processedRows;
                totalCount.textContent = totalRowsToProcess;
                
                if (processedRows === 0) {
                    timeRemainingValue.textContent = 'Calcul en cours...';
                } else {
                    const elapsed = Date.now() - processingStartTime;
                    const avgTimePerFile = elapsed / processedRows;
                    const remainingFiles = totalRowsToProcess - processedRows;
                    const estimatedRemainingMs = remainingFiles * avgTimePerFile;
                    
                    timeRemainingValue.textContent = formatTime(estimatedRemainingMs);
                }
            }
        }

        function formatTime(milliseconds) {
            const seconds = Math.round(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            if (minutes > 0) {
                return `${minutes}m ${remainingSeconds}s`;
            } else {
                return `${remainingSeconds}s`;
            }
        }

        function stopTimeEstimation() {
            if (timeEstimationInterval) {
                clearInterval(timeEstimationInterval);
                timeEstimationInterval = null;
            }
        }

        // Fonction pour ajouter des logs
        function addLog(message, type = 'info') {
            const logsContent = document.getElementById('logsContent');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const time = new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-message">${message}</span>
            `;
            
            logsContent.appendChild(logEntry);
            logsContent.scrollTop = logsContent.scrollHeight;
        }




        // Fonction pour obtenir le nombre de valeurs attendues par type de graphique
        function getExpectedValuesCount(chartType) {
            switch (chartType) {
                case 'AGE':
                    return 5; // 15-24, 25-34, 35-49, 50-64, 65+
                case 'CSP':
                    return 0; // Variable selon les donn√©es
                default:
                    return 0; // Inconnu
            }
        }

        // Fonction de validation des donn√©es des graphiques
        function validateChartData(ageData, cspData, provData) {
            try {
                // Validation des donn√©es AGE
                if (ageData && ageData.trim()) {
                    const agePattern = /(\d+-\d+ ans(?:\s+ou\s+plus)?):\s*(\d+(?:\.\d+)?)%/g;
                    const ageMatches = [...ageData.matchAll(agePattern)];
                    if (ageMatches.length === 0) {
                        return { isValid: false, error: 'Format des donn√©es AGE invalide. Utilisez: "15-24 ans: 25%, 25-34 ans: 30%"' };
                    }
                    
                    // V√©rifier que la somme des pourcentages est proche de 100%
                    const totalAge = ageMatches.reduce((sum, match) => sum + parseFloat(match[2]), 0);
                    if (Math.abs(totalAge - 100) > 5) {
                        return { isValid: false, error: `La somme des pourcentages AGE doit √™tre proche de 100% (actuellement: ${totalAge.toFixed(1)}%)` };
                    }
                }
                
                // Validation des donn√©es CSP
                if (cspData && cspData.trim()) {
                    const cspPattern = /([^:]+):\s*(\d+(?:\.\d+)?)%/g;
                    const cspMatches = [...cspData.matchAll(cspPattern)];
                    if (cspMatches.length === 0) {
                        return { isValid: false, error: 'Format des donn√©es CSP invalide. Utilisez: "Cadres: 40%, Employ√©s: 35%"' };
                    }
                    
                    const totalCsp = cspMatches.reduce((sum, match) => sum + parseFloat(match[2]), 0);
                    if (Math.abs(totalCsp - 100) > 5) {
                        return { isValid: false, error: `La somme des pourcentages CSP doit √™tre proche de 100% (actuellement: ${totalCsp.toFixed(1)}%)` };
                    }
                }
                
                
                
                return { isValid: true };
            } catch (error) {
                return { isValid: false, error: `Erreur de validation: ${error.message}` };
            }
        }

        // Gestion de la soumission du formulaire
        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const excelFile = document.getElementById('excelFile').files[0];
            const powerpointFile = document.getElementById('powerpointFile').files[0];
            const emailDestination = document.getElementById('emailInput').value;
            const outputPrefix = 'rapport_audience';
            
            // R√©cup√©rer les donn√©es des graphiques saisies par l'utilisateur
            const ageData = document.getElementById('ageData').value;
            const cspData = document.getElementById('cspData').value;
            const provData = document.getElementById('provData').value;

            addLog(`Validation: Excel=${excelFile ? 'OK' : 'MANQUANT'}, PowerPoint=${powerpointFile ? 'OK' : 'MANQUANT'}, Email=${emailDestination ? 'OK' : 'MANQUANT'}`, 'info');
            
            // Validation des donn√©es des graphiques
            const chartDataValidation = validateChartData(ageData, cspData, provData);
            if (!chartDataValidation.isValid) {
                addLog(`Erreur validation donn√©es graphiques: ${chartDataValidation.error}`, 'error');
                return;
            }
            
            if (!excelFile) {
                addLog('Veuillez s√©lectionner un fichier Excel', 'error');
                return;
            }
            
            if (!powerpointFile) {
                addLog('Veuillez s√©lectionner un fichier PowerPoint', 'error');
                return;
            }

            if (!emailDestination) {
                addLog('Veuillez saisir l\'email de destination', 'error');
                return;
            }


            document.getElementById('formContainer').classList.add('hidden');
            document.getElementById('loadingScreen').classList.add('active');

            const dots = document.querySelector('.dots');
            let dotCount = 0;
            const dotInterval = setInterval(() => {
                dotCount = (dotCount + 1) % 4;
                dots.textContent = '.'.repeat(dotCount);
            }, 500);

            try {
                addLog('D√©marrage du traitement local...', 'info');
                const result = await processFilesLocally(excelFile, powerpointFile, outputPrefix, emailDestination, null, {
                    'AGE': ageData,
                    'SOCIO-PRO': cspData
                });
                
                clearInterval(dotInterval);
                
                if (result.success) {
                    addLog('Traitement r√©ussi!', 'success');
                    showLocalProcessingResult(result);
                } else {
                    addLog(`√âchec du traitement: ${result.error}`, 'error');
                    showErrorResult(result.error);
                }
            } catch (error) {
                clearInterval(dotInterval);
                stopTimeEstimation(); // Arr√™ter l'estimation du temps en cas d'erreur
                addLog(`Erreur: ${error.message}`, 'error');
                showErrorResult(error.message);
            }
            
            document.getElementById('uploadForm').reset();
            document.getElementById('excelLabel').querySelector('span').textContent = 'S√©lectionner un fichier Excel (.xlsx, .xls)';
            document.getElementById('excelLabel').classList.remove('has-file');
            document.getElementById('powerpointLabel').querySelector('span').textContent = 'S√©lectionner un fichier PowerPoint (.pptx, .ppt)';
            document.getElementById('powerpointLabel').classList.remove('has-file');
            
            document.getElementById('formContainer').classList.remove('hidden');
            document.getElementById('loadingScreen').classList.remove('active');
        });

        // Fonction pour basculer l'affichage de la console
        function toggleConsole() {
            const console = document.getElementById('logsContainer');
            const button = document.getElementById('toggleConsoleBtn');
            
            if (console.style.display === 'none' || console.style.display === '') {
                console.style.display = 'block';
                button.textContent = 'Masquer Console';
            } else {
                console.style.display = 'none';
                button.textContent = 'Console';
            }
        }

        // Ajouter l'√©v√©nement au bouton console
        document.addEventListener('DOMContentLoaded', function() {
            const toggleBtn = document.getElementById('toggleConsoleBtn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleConsole);
            }
        });

        // Fonction pour afficher la documentation (version professionnelle)
        function showDocumentation() {
            const doc = `
DOCUMENTATION - G√âN√âRATEUR DE RAPPORTS D'AUDIENCE

FONCTIONNALIT√âS
‚Ä¢ G√©n√©ration automatique de rapports PowerPoint
‚Ä¢ Traitement des donn√©es Excel (Performance m√©dia, Audience, Provenance)
‚Ä¢ Gestion des pages de garde selon le type de flanc
‚Ä¢ Masquage automatique des diapositives selon le type de flanc
‚Ä¢ Envoi automatique par email via API Taskalys

FICHIERS REQUIS
‚Ä¢ Fichier Excel avec feuilles : "Performance m√©dia", "Audience", "Provenance"
‚Ä¢ Template PowerPoint avec variables {VILLE}, {PERIODE}, {AUDIENCE}, etc.

VARIABLES DISPONIBLES
‚Ä¢ {VILLE} - Nom de la ville (majuscules)
‚Ä¢ {PERIODE} - P√©riode format√©e (ex: "du 1 janvier 2024 au 7 janvier 2024")
‚Ä¢ {AUDIENCE} - Audience cible format√©e
‚Ä¢ {ODV} - Nombre d'ODV format√©
‚Ä¢ {NB_SEMAINE} - Num√©ro de semaine (1-52)

 EMAIL
 ‚Ä¢ Template personnalisable avec variables
 ‚Ä¢ Fichiers .txt avec objet "Buster x [client] - Vos rapports d'audience"
 ‚Ä¢ Envoi automatique via API Taskalys
 ‚Ä¢ Fichiers organis√©s par hi√©rarchie (Ann√©e/Semaine/Ville/Face/Version)

MASQUAGE DES DIAPOSITIVES
‚Ä¢ Flanc Gauche : masque les diapositives 1, 6 et 7
‚Ä¢ Flanc Droit : masque les diapositives 2, 5 et 6
‚Ä¢ Arri√®re : masque les diapositives 2, 5 et 7
‚Ä¢ R√®gle sp√©ciale Brest + Flanc Droit : affiche la diapositive 8 et masque les diapositives 5, 6 et 7
‚Ä¢ Diapositive 8 : masqu√©e dans tous les autres cas
‚Ä¢ Les diapositives masqu√©es ne sont pas visibles dans l'√©diteur PowerPoint

TRAITEMENT
‚Ä¢ Limit√© √† 3 lignes en mode debug
‚Ä¢ Estimation du temps en temps r√©el
‚Ä¢ Masquage des slides selon le type de flanc
‚Ä¢ G√©n√©ration de ZIP avec hi√©rarchie de dossiers
            `;
            
            alert(doc);
            return;
        }

        // Gestionnaire d'√©v√©nements pour les clics sur les boutons
        document.getElementById('submitBtn').addEventListener('click', function(e) {
            e.preventDefault();
            
            const excelFile = document.getElementById('excelFile').files[0];
            const powerpointFile = document.getElementById('powerpointFile').files[0];
            const emailDestination = document.getElementById('emailInput').value;
            const emailTemplate = document.getElementById('emailTemplateEditor').value;
            
            if (!excelFile || !powerpointFile) {
                showErrorResult('Veuillez s√©lectionner un fichier Excel et un template PowerPoint.');
                return;
            }
            
            if (!emailDestination.trim()) {
                showErrorResult('Veuillez saisir une adresse email de destination.');
                return;
            }
            
            // D√©marrer le traitement
            processFilesLocally(excelFile, powerpointFile, 'rapport_audience', emailDestination, emailTemplate);
        });

        // Gestion de l'interface de logs
        document.getElementById('clearLogsBtn').addEventListener('click', function() {
            const logsContent = document.getElementById('logsContent');
            logsContent.innerHTML = `
                <div class="log-entry info">
                    <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                    <span class="log-message">Logs effac√©s - Interface pr√™te</span>
                </div>
            `;
        });

        // Toggle pour r√©duire/agrandir les logs
        document.querySelector('.logs-header').addEventListener('click', function() {
            const logsContainer = document.getElementById('logsContainer');
            logsContainer.classList.toggle('collapsed');
        });

        // Animation des points de chargement
        const dots = document.querySelector('.dots');
        let dotCount = 0;
        setInterval(() => {
            if (document.getElementById('loadingScreen').classList.contains('active')) {
                dotCount = (dotCount + 1) % 4;
                dots.textContent = '.'.repeat(dotCount);
            }
        }, 500);
    </script>
</body>
</html>
