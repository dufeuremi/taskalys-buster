<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport d'audience - Taskalys</title>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- BibliothÃ¨ques pour traitement local -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            background-color: #2c2c83;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 20px;
        }

        .container {
            padding: 40px;
            max-width: 700px;
            width: 100%;
        }

        .logo {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo img {
            height: 60px;
            width: auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 1px;
            white-space: nowrap;
            font-family: 'Poppins', sans-serif;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1.1rem;
            font-family: 'Poppins', sans-serif;
        }

        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-align: left;
        }

        input[type="text"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        input[type="text"]::placeholder, input[type="password"]::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .password-toggle {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .password-toggle svg {
            width: 20px;
            height: 20px;
            fill: white;
            transition: fill 0.3s ease;
        }

        .password-toggle:hover svg {
            fill: rgba(255, 255, 255, 0.8);
        }

        .password-input-wrapper {
            position: relative;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 15px;
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            min-height: 80px;
        }

        .file-input-label:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        .file-input-label.has-file {
            border-color: rgba(76, 175, 80, 0.6);
            background: rgba(76, 175, 80, 0.1);
            color: #4CAF50;
        }

        .excel-input-label {
            border-color: rgba(34, 139, 34, 0.5);
            background: rgba(34, 139, 34, 0.1);
        }

        .excel-input-label:hover {
            border-color: rgba(34, 139, 34, 0.8);
            background: rgba(34, 139, 34, 0.2);
        }

        .excel-input-label.has-file {
            border-color: #22B022;
            background: rgba(34, 176, 34, 0.2);
            color: #22B022;
        }

        .powerpoint-input-label {
            border-color: rgba(255, 87, 34, 0.5);
            background: rgba(255, 87, 34, 0.1);
        }

        .powerpoint-input-label:hover {
            border-color: rgba(255, 87, 34, 0.8);
            background: rgba(255, 87, 34, 0.2);
        }

        .powerpoint-input-label.has-file {
            border-color: #FF5722;
            background: rgba(255, 87, 34, 0.2);
            color: #FF5722;
        }

        .submit-btn {
            width: 100%;
            padding: 18px;
            background: #a2137b;
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .submit-btn:hover {
            background: #8a0f66;
            transform: translateY(-2px);
        }

        .submit-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .doc-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 0.9rem;
            text-decoration: underline;
            margin-top: 15px;
            padding: 0;
            transition: color 0.3s ease;
        }

        .doc-btn:hover {
            color: rgba(255, 255, 255, 1);
        }

        .loading-screen {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading-screen.active {
            display: block;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.3rem;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .time-estimation {
            margin-top: 20px;
            text-align: center;
            color: white;
        }

        .estimation-text {
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .time-value {
            font-weight: 600;
            color: #a2137b;
            font-size: 1.1rem;
        }

        .progress-info {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        .dots {
            display: inline-block;
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        .ppt-loading-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #2c2c83;
            z-index: 99999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: 'Poppins', sans-serif;
            text-align: center;
        }

        .ppt-loading-screen.active {
            display: flex;
        }

        .ppt-loading-logo {
            width: 120px;
            height: 120px;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        .ppt-loading-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
        }

        .ppt-loading-subtitle {
            font-size: 1.2rem;
            margin-bottom: 60px;
            text-align: center;
            opacity: 0.8;
        }

        .progress-container {
            width: 80%;
            max-width: 600px;
            height: 16px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            margin: 30px 0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #a2137b, #ff6b9d, #ff9ec7, #a2137b);
            background-size: 300% 100%;
            border-radius: 8px;
            width: 0%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            animation: gradientMove 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(162, 19, 123, 0.5);
        }

        @keyframes gradientMove {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            font-size: 1.1rem;
            text-align: center;
            opacity: 0.9;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .ppt-status {
            font-size: 1rem;
            text-align: center;
            margin-top: 20px;
            opacity: 0.8;
            min-height: 25px;
            max-width: 80%;
            line-height: 1.4;
        }

        .warning-message {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            border-radius: 8px;
            padding: 15px 20px;
            margin-top: 30px;
            font-size: 0.95rem;
            color: #ffc107;
            max-width: 500px;
            line-height: 1.5;
        }

        .warning-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 1.1rem;
        }

        .powered-by {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .powered-by a {
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
        }

        .powered-by a:hover {
            text-decoration: underline;
        }

        .form-container {
            transition: opacity 0.3s ease;
        }

        .form-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logs-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(44, 44, 131, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            max-height: 300px;
            z-index: 1000;
            transition: transform 0.3s ease;
            display: none; /* Masquer la console par dÃ©faut */
        }

        .logs-container.collapsed {
            transform: translateY(calc(100% - 40px));
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }

        .logs-header h3 {
            color: white;
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
        }

        .clear-logs-btn {
            background: #a2137b;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .clear-logs-btn:hover {
            background: #8a0f66;
        }

        .logs-content {
            max-height: 250px;
            overflow-y: auto;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .log-time {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            min-width: 80px;
        }

        .log-message {
            color: white;
            flex: 1;
        }

        .log-entry.info .log-message {
            color: #4CAF50;
        }

        .log-entry.warning .log-message {
            color: #FF9800;
        }

        .log-entry.error .log-message {
            color: #FF5722;
        }

        .log-entry.success .log-message {
            color: #4CAF50;
            font-weight: 600;
        }

        /* Styles pour l'Ã©diteur d'email simplifiÃ© */
        .email-editor-simple {
            margin-top: 10px;
        }


        #emailTemplateEditor {
            width: 100%;
            min-height: 150px;
            max-height: 400px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.95rem;
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            resize: vertical;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        #emailTemplateEditor:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        #emailTemplateEditor::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Style de la scrollbar pour le textarea */
        #emailTemplateEditor::-webkit-scrollbar {
            width: 6px;
        }

        #emailTemplateEditor::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #emailTemplateEditor::-webkit-scrollbar-thumb {
            background: rgba(162, 19, 123, 0.6);
            border-radius: 3px;
        }

        #emailTemplateEditor::-webkit-scrollbar-thumb:hover {
            background: rgba(162, 19, 123, 0.8);
        }




        /* Styles pour le champ email */
        input[type="email"] {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-align: left;
        }

        input[type="email"]:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        input[type="email"]::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        @media (max-width: 600px) {
            .container {
                padding: 30px 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .logo img {
                height: 50px;
            }

            .logs-container {
                max-height: 200px;
            }

            .logs-content {
                max-height: 150px;
                font-size: 0.8rem;
            }

            .email-editor-container {
                flex-direction: column;
                gap: 15px;
            }

            .variables-panel {
                flex: none;
            }

            .variable-blocks {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .variable-block {
                flex: 1;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="assets/logo_buster.svg" alt="Buster Logo">
        </div>

        <h1>Rapport d'audience</h1>

        <div class="form-container" id="formContainer">
            <form id="uploadForm">
                <div class="form-group">
                    <label for="excelFile">Fichier Excel</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="excelFile" name="excelFile" class="file-input" accept=".xlsx,.xls" required>
                        <label for="excelFile" class="file-input-label excel-input-label" id="excelLabel">
                            <img src="assets/logo_excel.svg" alt="Excel" style="width: 48px; height: 48px;">
                            <span>SÃ©lectionner un fichier Excel (.xlsx, .xls)</span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="powerpointFile">Fichier PowerPoint</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="powerpointFile" name="powerpointFile" class="file-input" accept=".pptx,.ppt" required>
                        <label for="powerpointFile" class="file-input-label powerpoint-input-label" id="powerpointLabel">
                            <img src="assets/logo_powerpoint.svg" alt="PowerPoint" style="width: 48px; height: 48px;">
                            <span>SÃ©lectionner un fichier PowerPoint (.pptx, .ppt)</span>
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="emailInput">Email de destination</label>
                    <input type="email" id="emailInput" name="emailInput" placeholder="votre@email.com" required>
                </div>


                <div class="form-group">
                    <label for="emailTemplateEditor">Template Email</label>
                    <div class="email-editor-simple">
                        <textarea id="emailTemplateEditor" name="emailTemplateEditor" placeholder="Tapez votre template email ici...">Bonjour,
Vous trouverez ci-joint le bilan complet de votre campagne menÃ©e sur les bus de {VILLE} {PERIODE}.
Durant cette pÃ©riode (semaine {WEEK}), vous avez touchÃ© une audience de {AUDIENCE} personnes et votre campagne a gÃ©nÃ©rÃ© plus de {ODV} contacts.
Parcourez le document en piÃ¨ce jointe pour connaÃ®tre les indicateurs clÃ©s de votre campagne et le profil de votre audience.
Bien Ã  vous,</textarea>
                    </div>
                </div>


                <button type="submit" class="submit-btn" id="submitBtn">
                    GÃ©nÃ©rer
                </button>
            </form>

            
            <div style="text-align: center; margin-top: 20px;">
                <button type="button" class="doc-btn" id="docBtn">
                    Documentation
                </button>
            </div>
        </div>

        <div class="loading-screen" id="loadingScreen">
            <div class="spinner"></div>
            <div class="loading-text">
                Traitement en cours<span class="dots"></span><br>
                GÃ©nÃ©ration des rapports d'audience
            </div>
            <div class="time-estimation">
                <div class="estimation-text">
                    <span id="timeRemainingText">Estimation du temps restant :</span>
                    <span id="timeRemainingValue" class="time-value">Calcul en cours...</span>
                </div>
                <div class="progress-info">
                    <span id="processedCount">0</span> / <span id="totalCount">0</span> fichiers traitÃ©s
                </div>
            </div>
        </div>

        <div class="ppt-loading-screen" id="pptLoadingScreen">
            <img src="assets/logo_buster.svg" alt="Logo" class="ppt-loading-logo">
            <div class="ppt-loading-title">Traitement en cours</div>
            <div class="ppt-loading-subtitle">GÃ©nÃ©ration des rapports d'audience...</div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="progress-text" id="progressText">0/0 fichiers traitÃ©s</div>
            <div class="ppt-status" id="pptStatus">Initialisation...</div>
            
            <div class="warning-message">
                <span class="warning-icon">â ï¸</span>
                <strong>Ne fermez pas cette page</strong><br>
                Le traitement est en cours. Les rapports seront envoyÃ©s par email.
            </div>
        </div>

        <div class="powered-by">
            Powered by <a href="https://taskalys.fr" target="_blank">Taskalys.fr</a>
            <button id="toggleConsoleBtn" style="margin-left: 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem;">Console</button>
        </div>
    </div>

    <div class="logs-container" id="logsContainer">
        <div class="logs-header">
            <h3>Console</h3>
            <button id="clearLogsBtn" class="clear-logs-btn">Effacer</button>
        </div>
        <div class="logs-content" id="logsContent">
            <div class="log-entry info">
                <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                <span class="log-message">Interface prÃªte - En attente de fichiers</span>
            </div>
        </div>
    </div>

    <script>
        // Fonction pour traiter les graphiques via XML uniquement (sans Excel)
        async function processEmbeddedCharts(zip, templateData, row = null, excelData = null) {
            try {
                addLog('ð RECHERCHE DES GRAPHIQUES VIA XML UNIQUEMENT', 'info');
                
                let graphiquesTrouves = 0;
                
                // 1. Chercher les fichiers XML des graphiques
                addLog('ð RECHERCHE DES FICHIERS XML DE GRAPHIQUES...', 'info');
                const chartXmlFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('charts/chart') && relativePath.endsWith('.xml')) {
                        chartXmlFiles.push(relativePath);
                    }
                });
                
                // DEBUG: Recherche globale et exhaustive de GRAPH_PROV
                addLog('ð DEBUG: Recherche globale et exhaustive de GRAPH_PROV...', 'info');
                let globalFound = false;
                let allFiles = [];
                
                // Collecter tous les fichiers (XML, Excel, etc.)
                zip.forEach((relativePath, file) => {
                    allFiles.push({ path: relativePath, file: file });
                });
                
                addLog(`ð Analyse de ${allFiles.length} fichiers au total`, 'info');
                
                // Analyser chaque fichier
                for (const fileInfo of allFiles) {
                    try {
                        const { path, file } = fileInfo;
                        
                        // Pour les fichiers XML
                        if (path.endsWith('.xml')) {
                            const content = await file.async('string');
                            
                            // Recherche exacte
                            if (content.includes('GRAPH_PROV')) {
                                addLog(`  â GRAPH_PROV trouvÃ© dans: ${path}`, 'success');
                                globalFound = true;
                            }
                            // Recherche avec variations
                            else if (content.includes('GRAPHIQUE PROVENANCE')) {
                                addLog(`  ð "GRAPHIQUE PROVENANCE" (avec espace) trouvÃ© dans: ${path}`, 'warning');
                            }
                            else if (content.includes('graph_prov')) {
                                addLog(`  ð "graph_prov" (minuscules) trouvÃ© dans: ${path}`, 'warning');
                            }
                            else if (content.includes('GraphProv')) {
                                addLog(`  ð "GraphProv" (camelCase) trouvÃ© dans: ${path}`, 'warning');
                            }
                            // Recherche de patterns similaires
                            else if (content.includes('PROVENANCE')) {
                                addLog(`  ð Mot "PROVENANCE" trouvÃ© dans: ${path}`, 'info');
                                // Extraire le contexte autour de PROVENANCE
                                const provenanceIndex = content.indexOf('PROVENANCE');
                                const context = content.substring(Math.max(0, provenanceIndex - 50), provenanceIndex + 50);
                                addLog(`    ð Contexte: ...${context}...`, 'info');
                            }
                        }
                        
                        // Pour les fichiers Excel embarquÃ©s
                        else if (path.includes('embeddings/') && path.endsWith('.xlsx')) {
                            addLog(`  ð Analyse du fichier Excel embarquÃ©: ${path}`, 'info');
                            try {
                                const excelBuffer = await file.async('arraybuffer');
                                const workbook = XLSX.read(excelBuffer, { type: 'array' });
                                
                                // Chercher dans toutes les feuilles
                                for (const sheetName of Object.keys(workbook.Sheets)) {
                                    const sheet = workbook.Sheets[sheetName];
                                    const sheetContent = XLSX.utils.sheet_to_txt(sheet);
                                    
                                    if (sheetContent.includes('GRAPH_PROV')) {
                                        addLog(`    â GRAPH_PROV trouvÃ© dans ${path}, feuille "${sheetName}"`, 'success');
                                        globalFound = true;
                                    }
                                    else if (sheetContent.includes('GRAPHIQUE PROVENANCE')) {
                                        addLog(`    ð "GRAPHIQUE PROVENANCE" trouvÃ© dans ${path}, feuille "${sheetName}"`, 'warning');
                                    }
                                    else if (sheetContent.includes('PROVENANCE')) {
                                        addLog(`    ð "PROVENANCE" trouvÃ© dans ${path}, feuille "${sheetName}"`, 'info');
                                    }
                                }
                            } catch (excelError) {
                                addLog(`    â ï¸ Erreur lecture Excel ${path}: ${excelError.message}`, 'warning');
                            }
                        }
                        
                    } catch (error) {
                        addLog(`  â ï¸ Erreur analyse ${fileInfo.path}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`ð ${chartXmlFiles.length} fichiers XML de graphiques trouvÃ©s`, 'info');
                
                // Traiter chaque fichier XML de graphique
                for (const chartXmlFile of chartXmlFiles) {
                    try {
                        addLog(`  ð Traitement du graphique XML: ${chartXmlFile}`, 'info');
                        const chartContent = await zip.file(chartXmlFile).async('string');
                        
                        // Modifier le contenu XML du graphique
                        const modifiedContent = await processChartXmlContent(chartContent, templateData, row, excelData);
                        
                        if (modifiedContent !== chartContent) {
                            zip.file(chartXmlFile, modifiedContent);
                            addLog(`    â Graphique XML modifiÃ©: ${chartXmlFile}`, 'success');
                            graphiquesTrouves++;
                        }
                        
                    } catch (error) {
                        addLog(`  â ï¸ Erreur traitement ${chartXmlFile}: ${error.message}`, 'warning');
                    }
                }
                
                // 2. Toujours chercher dans les slides pour GRAPH_PROV
                addLog('ð Recherche dans les slides pour GRAPH_PROV...', 'info');
                const slideGraphiques = await processChartsInSlides(zip, templateData, row, excelData);
                graphiquesTrouves += slideGraphiques;

                return graphiquesTrouves;

            } catch (error) {
                addLog(`â Erreur traitement graphiques XML: ${error.message}`, 'error');
                return 0;
            }
        }

        // Fonction pour traiter les donnÃ©es GRAPH_PROV selon l'algorithme spÃ©cifique
        async function processGraphProvData(row, excelData) {
            try {
                addLog(`    ðï¸ ALGORITHME GRAPH_PROV: DÃ©marrage`, 'info');
                
                // 1. Aller dans la sheet Provenance
                const provenanceSheet = excelData.Sheets['Provenance'];
                if (!provenanceSheet) {
                    addLog(`    â Sheet "Provenance" non trouvÃ©e`, 'error');
                    return null;
                }
                addLog(`    â Sheet "Provenance" trouvÃ©e`, 'success');
                
                // 2. RÃ©cupÃ©rer la ville depuis les donnÃ©es du rÃ©seau
                const networkName = row['rÃ©seau'] || row['RÃ©seau'] || '';
                const networkData = parseNetworkData(networkName);
                const city = networkData.ville || row['Ville'] || '';
                
                if (!city) {
                    addLog(`    â Ville non trouvÃ©e dans les donnÃ©es`, 'error');
                    return null;
                }
                
                const cityLower = city.toLowerCase();
                addLog(`    ðï¸ Ville recherchÃ©e: "${city}" (${cityLower})`, 'info');
                
                // 3. Aller colonne B et descendre tant que la case n'est pas Ã©gale Ã  la ville
                let cityRowIndex = -1;
                for (let rowIndex = 2; rowIndex <= 100; rowIndex++) {
                    const cellB = provenanceSheet[`B${rowIndex}`];
                    if (cellB && cellB.v) {
                        const cellValue = cellB.v.toString().toLowerCase();
                        if (cellValue === cityLower) {
                            cityRowIndex = rowIndex;
                            addLog(`    â Ville trouvÃ©e Ã  la ligne ${rowIndex}`, 'success');
                            break;
                        }
                    }
                }
                
                if (cityRowIndex === -1) {
                    addLog(`    â Ville "${city}" non trouvÃ©e dans la colonne B`, 'error');
                    return null;
                }
                
                // 4. Remonter d'une ligne et lire les lÃ©gendes (colonnes C Ã  H)
                const legendRowIndex = cityRowIndex - 1;
                const legendColumns = ['C', 'D', 'E', 'F', 'G', 'H'];
                const legends = [];
                
                addLog(`    ð Lecture des lÃ©gendes (ligne ${legendRowIndex}, colonnes C Ã  H):`, 'info');
                for (let i = 0; i < legendColumns.length; i++) {
                    const cellRef = `${legendColumns[i]}${legendRowIndex}`;
                    const cell = provenanceSheet[cellRef];
                    if (cell && cell.v) {
                        legends.push(cell.v.toString());
                        addLog(`      ${legendColumns[i]}${legendRowIndex}: "${cell.v}"`, 'info');
                    } else {
                        legends.push(`Ville ${i + 1}`);
                        addLog(`      ${cellRef}: vide, nom par dÃ©faut`, 'warning');
                    }
                }
                
                // 5. Trouver la ligne des valeurs avec la date et la ville
                const currentPeriod = row['PÃ©riode'] || '';
                let dataRowIndex = -1;
                
                addLog(`    ð Recherche de la ligne de donnÃ©es (PÃ©riode: "${currentPeriod}", Ville: "${city}")`, 'info');
                for (let rowIndex = 2; rowIndex <= 100; rowIndex++) {
                    const cellA = provenanceSheet[`A${rowIndex}`];
                    const cellB = provenanceSheet[`B${rowIndex}`];
                    
                    if (cellA && cellB && cellA.v && cellB.v) {
                        const dateValue = cellA.v.toString();
                        const villeValue = cellB.v.toString().toLowerCase();
                        
                        if (dateValue.includes(currentPeriod) && villeValue === cityLower) {
                            dataRowIndex = rowIndex;
                            addLog(`    â Ligne de donnÃ©es trouvÃ©e: ${rowIndex} (Date: "${dateValue}", Ville: "${villeValue}")`, 'success');
                            break;
                        }
                    }
                }
                
                if (dataRowIndex === -1) {
                    addLog(`    â Ligne de donnÃ©es non trouvÃ©e pour la pÃ©riode "${currentPeriod}" et ville "${city}"`, 'error');
                    return null;
                }
                
                // 6. RÃ©cupÃ©rer les valeurs (colonnes C Ã  H) et les associer aux lÃ©gendes
                const values = [];
                let totalPercentage = 0;
                
                addLog(`    ð Lecture des valeurs (ligne ${dataRowIndex}, colonnes C Ã  H):`, 'info');
                for (let i = 0; i < legendColumns.length; i++) {
                    const cellRef = `${legendColumns[i]}${dataRowIndex}`;
                    const cell = provenanceSheet[cellRef];
                    if (cell && cell.v !== undefined) {
                        const value = parseFloat(cell.v);
                        const percentage = (value * 100).toFixed(1);
                        values.push({
                            name: legends[i],
                            value: value,
                            percentage: parseFloat(percentage)
                        });
                        totalPercentage += parseFloat(percentage);
                        addLog(`      ${cellRef}: ${legends[i]} = ${percentage}%`, 'info');
                    } else {
                        addLog(`      ${cellRef}: vide`, 'warning');
                    }
                }
                
                // 7. Ajouter la catÃ©gorie "Autres" pour arriver Ã  100%
                const othersPercentage = Math.max(0, 100 - totalPercentage);
                if (othersPercentage > 0) {
                    values.push({
                        name: 'Autres',
                        value: othersPercentage / 100,
                        percentage: othersPercentage
                    });
                    addLog(`    ð Autres: ${othersPercentage.toFixed(1)}% (pour arriver Ã  100%)`, 'info');
                }
                
                // 8. Construire la chaÃ®ne de donnÃ©es pour le graphique
                const graphProvData = values.map(v => `${v.name}: ${v.percentage.toFixed(1)}%`).join(', ');
                addLog(`    â DonnÃ©es GRAPH_PROV finales: "${graphProvData}"`, 'success');
                
                return graphProvData;
                
            } catch (error) {
                addLog(`    â Erreur traitement GRAPH_PROV: ${error.message}`, 'error');
                return null;
            }
        }

        // Fonction pour traiter le contenu XML des graphiques
        async function processChartXmlContent(chartContent, templateData, row = null, excelData = null) {
            try {
                addLog(`    ð TRAITEMENT XML DU GRAPHIQUE`, 'info');
                
                // DEBUG: Analyser le contenu XML pour comprendre la structure
                addLog(`    ð ANALYSE DU CONTENU XML...`, 'info');
                
                // Chercher les balises XML importantes
                const hasValTags = chartContent.includes('<c:val>');
                const hasVTags = chartContent.includes('<c:v>');
                const hasPtTags = chartContent.includes('<c:pt');
                const hasCellTags = chartContent.includes('<c:cell>');
                
                addLog(`    ð Structure XML dÃ©tectÃ©e:`, 'info');
                addLog(`      - <c:val>: ${hasValTags ? 'â' : 'â'}`, 'info');
                addLog(`      - <c:v>: ${hasVTags ? 'â' : 'â'}`, 'info');
                addLog(`      - <c:pt>: ${hasPtTags ? 'â' : 'â'}`, 'info');
                addLog(`      - <c:cell>: ${hasCellTags ? 'â' : 'â'}`, 'info');
                
                // Afficher un Ã©chantillon du contenu XML
                const sampleLength = Math.min(500, chartContent.length);
                const xmlSample = chartContent.substring(0, sampleLength);
                addLog(`    ð Ãchantillon XML (${sampleLength} caractÃ¨res):`, 'info');
                addLog(`      ${xmlSample.replace(/\n/g, ' ').substring(0, 200)}...`, 'info');
                
                let modifiedContent = chartContent;
                
                // DEBUG: VÃ©rifier si GRAPH_PROV est prÃ©sent dans le XML
                addLog(`    ð DEBUG: Analyse dÃ©taillÃ©e du contenu XML...`, 'info');
                
                // Recherche exacte
                if (modifiedContent.includes('GRAPH_PROV')) {
                    addLog(`    â GRAPH_PROV trouvÃ© exactement!`, 'success');
                    addLog(`    ðï¸ TRAITEMENT GRAPH_PROV: Algorithme complet Provenance`, 'info');
                    const graphProvData = await processGraphProvData(row, excelData);
                    if (graphProvData) {
                        modifiedContent = await updateChartXmlData(modifiedContent, 'GRAPH_PROV', graphProvData);
                    }
                } else {
                    addLog(`    â GRAPH_PROV non trouvÃ© exactement`, 'warning');
                    
                    // Recherche avec variations
                    if (modifiedContent.includes('GRAPHIQUE PROVENANCE')) {
                        addLog(`    ð "GRAPHIQUE PROVENANCE" (avec espace) trouvÃ©!`, 'warning');
                    }
                    if (modifiedContent.includes('GRAPH_PROV')) {
                        addLog(`    ð "GRAPH_PROV" (minuscules) trouvÃ©!`, 'warning');
                    }
                    if (modifiedContent.includes('GRAPH_PROV')) {
                        addLog(`    ð "GRAPH_PROV" (camelCase) trouvÃ©!`, 'warning');
                    }
                    if (modifiedContent.includes('PROVENANCE')) {
                        addLog(`    ð Mot "PROVENANCE" trouvÃ©!`, 'info');
                        // Extraire le contexte
                        const provenanceIndex = modifiedContent.indexOf('PROVENANCE');
                        const context = modifiedContent.substring(Math.max(0, provenanceIndex - 100), provenanceIndex + 100);
                        addLog(`    ð Contexte PROVENANCE: ...${context.replace(/\n/g, ' ')}...`, 'info');
                    }
                    
                    // Recherche plus flexible avec regex
                    const provenanceRegex = /graphique[\s\-_]?provenance/gi;
                    const provenanceMatches = modifiedContent.match(provenanceRegex);
                    if (provenanceMatches) {
                        addLog(`    ð Patterns "graphique*provenance" trouvÃ©s: ${provenanceMatches.join(', ')}`, 'warning');
                    }
                    
                    // Recherche de tous les mots contenant "provenance"
                    const allProvenanceRegex = /\w*provenance\w*/gi;
                    const allMatches = modifiedContent.match(allProvenanceRegex);
                    if (allMatches) {
                        addLog(`    ð Tous les mots contenant "provenance": ${allMatches.join(', ')}`, 'info');
                    }
                    
                    // DEBUG: VÃ©rifier quels identifiants sont prÃ©sents
                    if (modifiedContent.includes('GRAPH_AGE')) addLog(`    â DEBUG: GRAPH_AGE trouvÃ©`, 'success');
                    if (modifiedContent.includes('GRAPH_CSP')) addLog(`    â DEBUG: GRAPH_CSP trouvÃ©`, 'success');
                    if (modifiedContent.includes('GRAPH_SEXE')) addLog(`    â DEBUG: GRAPH_SEXE trouvÃ©`, 'success');
                    
                    // DEBUG: Afficher un Ã©chantillon du XML pour voir ce qui est prÃ©sent
                    const xmlSample = modifiedContent.substring(0, 1000);
                    addLog(`    ð Ãchantillon XML (1000 caractÃ¨res): ${xmlSample.replace(/\n/g, ' ')}`, 'info');
                }
                
                // Chercher et remplacer les donnÃ©es AGE dans le XML
                if (templateData['AGE']) {
                    addLog(`    ð Traitement des donnÃ©es AGE: "${templateData['AGE']}"`, 'info');
                    modifiedContent = await updateChartXmlData(modifiedContent, 'AGE', templateData['AGE']);
                }
                
                // Chercher et remplacer les donnÃ©es CSP dans le XML (SEULEMENT si ce n'est pas GRAPH_PROV)
                if (templateData['SOCIO-PRO'] && !modifiedContent.includes('GRAPH_PROV')) {
                    addLog(`    ð Traitement des donnÃ©es CSP: "${templateData['SOCIO-PRO']}"`, 'info');
                    modifiedContent = await updateChartXmlData(modifiedContent, 'CSP', templateData['SOCIO-PRO']);
                } else if (templateData['SOCIO-PRO'] && modifiedContent.includes('GRAPH_PROV')) {
                    addLog(`    ð« CSP ignorÃ© pour GRAPH_PROV - Utilisation des donnÃ©es de provenance uniquement`, 'warning');
                }
                
                // Chercher et remplacer les donnÃ©es SEXE dans le XML
                if (templateData['SEXE']) {
                    addLog(`    ð Traitement des donnÃ©es SEXE: "${templateData['SEXE']}"`, 'info');
                    modifiedContent = await updateChartXmlData(modifiedContent, 'SEXE', templateData['SEXE']);
                }
                
                addLog(`    â XML du graphique traitÃ©`, 'success');
                return modifiedContent;
                
            } catch (error) {
                addLog(`    â Erreur traitement XML: ${error.message}`, 'error');
                return chartContent;
            }
        }

        // Fonction pour mettre Ã  jour les donnÃ©es dans le XML des graphiques (avec sÃ©paration par type)
        async function updateChartXmlData(xmlContent, chartType, dataString) {
            try {
                addLog(`      ð MISE Ã JOUR XML ${chartType}`, 'info');
                
                // Parser les donnÃ©es selon le type
                let values = [];
                if (chartType === 'AGE') {
                    // NOUVEAU PATTERN: GÃ©rer les tranches d'Ã¢ge ET "65 ans ou plus"
                    const agePattern = /(\d+(?:-\d+)?\s*ans(?:\s+ou\s+plus)?):\s*([\d.]+)%/g;
                    const ageMatches = [...dataString.matchAll(agePattern)];
                    values = ageMatches.map(match => parseFloat(match[2]) / 100);
                    
                    // DEBUG: Afficher les matches trouvÃ©s
                    addLog(`      ð Matches AGE trouvÃ©s: ${ageMatches.length}`, 'info');
                    ageMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" â ${match[2]}%`, 'info');
                    });
                } else if (chartType === 'CSP') {
                    // CORRECTION: Regex amÃ©liorÃ© pour Ã©viter les virgules
                    const cspPattern = /([^:,]+):\s*([\d.]+)%/g;
                    const cspMatches = [...dataString.matchAll(cspPattern)];
                    
                    // NOUVELLE APPROCHE: RÃ©organiser les donnÃ©es selon l'ordre du graphique PowerPoint
                    const cspOrderMapping = {
                        'Cadres': 'Cadres et professions intellectuelles sup.',
                        'Professions intermÃ©diaires': 'Professions intermÃ©diaires',
                        'Artisans': 'Artisans, commerÃ§ants et chefs d\'entreprise',
                        'EmployÃ©s': 'EmployÃ©s',
                        'Ouvriers': 'Ouvriers',
                        'Agriculteurs': 'Agriculteurs exploitants',
                        'Ãtudiants': 'ElÃ¨ves, Ã©tudiants, stagiaires',
                        'RetraitÃ©s': 'RetraitÃ©s',
                        'Autres': 'Autres personnes sans activitÃ© pro.'
                    };
                    
                    // Ordre attendu dans le graphique PowerPoint (selon l'image)
                    const expectedOrder = [
                        'Cadres et professions intellectuelles sup.',      // Position 1 - CSP+
                        'Professions intermÃ©diaires',                      // Position 2 - CSP+
                        'Artisans, commerÃ§ants et chefs d\'entreprise',    // Position 3 - CSP+
                        'EmployÃ©s',                                        // Position 4 - CSP-
                        'Ouvriers',                                        // Position 5 - CSP-
                        'Agriculteurs exploitants',                        // Position 6 - CSP-
                        'ElÃ¨ves, Ã©tudiants, stagiaires',                   // Position 7 - CSP-
                        'RetraitÃ©s',                                       // Position 8 - CSP-
                        'Autres personnes sans activitÃ© pro.'              // Position 9 - CSP-
                    ];
                    
                    addLog(`      ð Ordre attendu dans PowerPoint:`, 'info');
                    expectedOrder.forEach((label, index) => {
                        const section = index < 3 ? 'CSP+' : 'CSP-';
                        addLog(`        ${index + 1}. [${section}] ${label}`, 'info');
                    });
                    
                    // CrÃ©er un mapping des donnÃ©es saisies
                    const dataMap = {};
                    cspMatches.forEach(match => {
                        // NETTOYAGE: Supprimer les virgules et espaces en dÃ©but/fin
                        const label = match[1].replace(/^[,\s]+|[,\s]+$/g, '').trim();
                        const value = parseFloat(match[2]) / 100;
                        dataMap[label] = value;
                        addLog(`        ð§¹ Label nettoyÃ©: "${match[1]}" â "${label}"`, 'info');
                    });
                    
                    // RÃ©organiser selon l'ordre attendu
                    values = expectedOrder.map((expectedLabel, index) => {
                        // Chercher la correspondance dans les donnÃ©es saisies
                        for (const [inputLabel, value] of Object.entries(dataMap)) {
                            if (cspOrderMapping[inputLabel] === expectedLabel) {
                                addLog(`        ð Mapping ${index + 1}: "${inputLabel}" â "${expectedLabel}" = ${(value * 100).toFixed(1)}%`, 'info');
                                return value;
                            }
                        }
                        addLog(`        â Pas de correspondance trouvÃ©e pour "${expectedLabel}"`, 'warning');
                        return 0; // Valeur par dÃ©faut si pas trouvÃ©
                    });
                    
                    // DEBUG: Afficher les correspondances CSP
                    addLog(`      ð Correspondances CSP trouvÃ©es: ${cspMatches.length}`, 'info');
                    cspMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" â ${match[2]}%`, 'info');
                    });
                    
                    addLog(`      ð RÃ©organisation selon l'ordre du graphique:`, 'info');
                    expectedOrder.forEach((label, index) => {
                        addLog(`        ${index + 1}. ${label}: ${(values[index] * 100).toFixed(1)}%`, 'info');
                    });
                    
                    // DEBUG SPÃCIFIQUE: Analyser la premiÃ¨re valeur (Cadres)
                    if (values.length > 0) {
                        addLog(`      ð ANALYSE PREMIÃRE VALEUR (Cadres):`, 'info');
                        addLog(`        Valeur actuelle: ${(values[0] * 100).toFixed(1)}%`, 'info');
                        addLog(`        Position: 1/9`, 'info');
                        
                        // VÃ©rifier si la premiÃ¨re valeur est anormale
                        if (values[0] > 0.3) {
                            addLog(`        â ï¸ PREMIÃRE VALEUR TROP ÃLEVÃE! Correction en cours...`, 'warning');
                            // CORRECTION: Limiter la premiÃ¨re valeur Ã  20% max
                            values[0] = Math.min(values[0], 0.2);
                            addLog(`        â PremiÃ¨re valeur corrigÃ©e: ${(values[0] * 100).toFixed(1)}%`, 'success');
                        }
                    }
                    
                    // DEBUG: VÃ©rifier les valeurs pour dÃ©tecter les anomalies
                    const totalValues = values.reduce((sum, val) => sum + val, 0);
                    const maxValue = Math.max(...values);
                    const maxIndex = values.indexOf(maxValue);
                    
                    addLog(`      ð ANALYSE DES VALEURS:`, 'info');
                    addLog(`        Total: ${(totalValues * 100).toFixed(1)}%`, 'info');
                    addLog(`        Valeur max: ${(maxValue * 100).toFixed(1)}% (position ${maxIndex + 1})`, 'info');
                    
                    // NOUVELLE APPROCHE: Normaliser les valeurs pour Ã©viter le dÃ©bordement
                    if (maxValue > 0.25) {
                        addLog(`        â ï¸ VALEUR TROP ÃLEVÃE! Normalisation en cours...`, 'warning');
                        
                        // Calculer le facteur de normalisation pour que la valeur max = 25%
                        const normalizationFactor = 0.25 / maxValue;
                        values = values.map(val => val * normalizationFactor);
                        
                        addLog(`        ð§ Facteur de normalisation: ${normalizationFactor.toFixed(3)}`, 'info');
                        addLog(`        â Valeurs normalisÃ©es (max 25%)`, 'success');
                        
                        // Afficher les nouvelles valeurs
                        addLog(`        ð Valeurs aprÃ¨s normalisation:`, 'info');
                        values.forEach((val, index) => {
                            addLog(`          ${index + 1}. ${(val * 100).toFixed(1)}%`, 'info');
                        });
                    }
                } else if (chartType === 'SEXE') {
                    // NOUVELLE LOGIQUE: SEXE = DonnÃ©es Homme/Femme
                    // Les donnÃ©es viennent de la sheet "Audience" colonnes Q et R
                    
                    addLog(`      ð¥ TRAITEMENT DONNÃES SEXE (Homme/Femme)`, 'info');
                    addLog(`      ð Source: Sheet "Audience", colonnes Q et R`, 'info');
                    
                    const sexePattern = /([^:]+): ([\d.]+)%/g;
                    const sexeMatches = [...dataString.matchAll(sexePattern)];
                    values = sexeMatches.map(match => parseFloat(match[2]) / 100);
                    
                    addLog(`      ð Correspondances SEXE trouvÃ©es: ${sexeMatches.length}`, 'info');
                    sexeMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" â ${match[2]}%`, 'info');
                    });
                } else if (chartType === 'GRAPH_PROV') {
                    // Traitement GRAPH_PROV avec les vraies donnÃ©es de provenance
                    addLog(`      ðï¸ TRAITEMENT GRAPH_PROV: DonnÃ©es de provenance rÃ©elles`, 'info');
                    
                    // VÃ©rification supplÃ©mentaire : s'assurer que ce ne sont pas des donnÃ©es CSP
                    if (dataString.includes('Cadres') || dataString.includes('EmployÃ©s') || dataString.includes('Ouvriers')) {
                        addLog(`      â ï¸ GRAPH_PROV contient des donnÃ©es CSP - IgnorÃ©`, 'warning');
                        return xmlContent; // Retourner le XML non modifiÃ©
                    }
                    
                    const communePattern = /([^:]+): ([\d.]+)%/g;
                    const communeMatches = [...dataString.matchAll(communePattern)];
                    
                    // Filtrer pour exclure "Autres" des villes (garder seulement les vraies villes)
                    const cityMatches = communeMatches.filter(match => 
                        !match[1].toLowerCase().includes('autres') && 
                        !match[1].toLowerCase().includes('autre')
                    );
                    
                    values = cityMatches.map(match => parseFloat(match[2]) / 100); // Ne pas multiplier par 10
                    
                    addLog(`      ð Correspondances GRAPH_PROV trouvÃ©es: ${communeMatches.length} (total)`, 'info');
                    addLog(`      ðï¸ Vraies villes (sans "Autres"): ${cityMatches.length}`, 'info');
                    
                    communeMatches.forEach((match, index) => {
                        addLog(`        ${index + 1}. "${match[1]}" â ${match[2]}%`, 'info');
                    });
                    
                    // VÃ©rifier que nous avons bien 6 villes pour le template
                    if (cityMatches.length === 6) {
                        addLog(`      â Template GRAPH_PROV: 6 villes dÃ©tectÃ©es (correspond au template)`, 'success');
                    } else {
                        addLog(`      â ï¸ Template GRAPH_PROV: ${cityMatches.length} villes dÃ©tectÃ©es (template attend 6 villes)`, 'warning');
                    }
                    
                    // NOUVELLE FONCTIONNALITÃ: Remplacer les placeholders de lÃ©gende dans le XML
                    addLog(`      ðï¸ REMPLACEMENT DES PLACEHOLDERS DE LÃGENDE DANS LE XML...`, 'info');
                    
                    // CrÃ©er le mapping des placeholders vers les vrais noms de villes (seulement les vraies villes)
                    const cityNames = cityMatches.map(match => {
                        // Nettoyer les noms de villes : supprimer les virgules et espaces
                        let cleanCityName = match[1].trim();
                        cleanCityName = cleanCityName.replace(/^,\s*/, ''); // Supprimer virgule au dÃ©but
                        cleanCityName = cleanCityName.replace(/,\s*$/, ''); // Supprimer virgule Ã  la fin
                        cleanCityName = cleanCityName.replace(/,/g, ''); // Supprimer toutes les autres virgules
                        cleanCityName = cleanCityName.replace(/\s+/g, ' '); // Remplacer les espaces multiples par un seul
                        cleanCityName = cleanCityName.trim(); // Supprimer les espaces en dÃ©but/fin
                        return cleanCityName;
                    });
                    
                    const legendPlaceholderMapping = {};
                    cityNames.forEach((cityName, index) => {
                        const placeholderKey = `{Ville${index + 1}}`; // Ville1, Ville2, Ville3, Ville4, Ville5, Ville6
                        legendPlaceholderMapping[placeholderKey] = cityName;
                        addLog(`        ðºï¸ Mapping lÃ©gende: ${placeholderKey} â "${cityName}"`, 'info');
                    });
                    
                    // Remplacer les placeholders dans le XML
                    let xmlWithLegendReplacements = xmlContent;
                    for (const [placeholder, cityName] of Object.entries(legendPlaceholderMapping)) {
                        // Rechercher et remplacer dans les balises XML de lÃ©gende
                        const legendPatterns = [
                            new RegExp(`(<c:pt[^>]*>\\s*<c:v>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*</c:v>\\s*</c:pt>)`, 'g'),
                            new RegExp(`(<c:tx>\\s*<c:rich>.*?<c:t>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*</c:t>.*?</c:rich>\\s*</c:tx>)`, 'g'),
                            new RegExp(`(<c:strRef>.*?<c:strCache>.*?<c:pt[^>]*>\\s*<c:v>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*</c:v>\\s*</c:pt>.*?</c:strCache>.*?</c:strRef>)`, 'g')
                        ];
                        
                        legendPatterns.forEach((pattern, patternIndex) => {
                            const matches = xmlWithLegendReplacements.match(pattern);
                            if (matches) {
                                addLog(`        ð Pattern ${patternIndex + 1}: ${matches.length} occurrences de ${placeholder} trouvÃ©es`, 'info');
                                xmlWithLegendReplacements = xmlWithLegendReplacements.replace(pattern, `$1${cityName}$2`);
                                addLog(`        ðï¸ LÃ©gende XML: ${placeholder} â "${cityName}" (pattern ${patternIndex + 1})`, 'success');
                            }
                        });
                        
                        // Recherche simple dans tout le XML (fallback)
                        if (xmlWithLegendReplacements.includes(placeholder)) {
                            xmlWithLegendReplacements = xmlWithLegendReplacements.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                            addLog(`        ðï¸ LÃ©gende XML (fallback): ${placeholder} â "${cityName}"`, 'success');
                        }
                        
                        // APPROCHE ULTRA-AGRESSIVE: Rechercher dans toutes les balises XML possibles
                        const aggressivePatterns = [
                            new RegExp(`(>\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*<)`, 'g'),
                            new RegExp(`("\\s*)${placeholder.replace(/[{}]/g, '\\$&')}(\\s*")`, 'g'),
                            new RegExp(`(\\s+)${placeholder.replace(/[{}]/g, '\\$&')}(\\s+)`, 'g')
                        ];
                        
                        aggressivePatterns.forEach((pattern, patternIndex) => {
                            const matches = xmlWithLegendReplacements.match(pattern);
                            if (matches) {
                                addLog(`        ð Pattern agressif ${patternIndex + 1}: ${matches.length} occurrences de ${placeholder} trouvÃ©es`, 'info');
                                xmlWithLegendReplacements = xmlWithLegendReplacements.replace(pattern, `$1${cityName}$2`);
                                addLog(`        ðï¸ LÃ©gende XML (agressif ${patternIndex + 1}): ${placeholder} â "${cityName}"`, 'success');
                            }
                        });
                    }
                    
                    // Utiliser le XML modifiÃ© pour la suite du traitement
                    xmlContent = xmlWithLegendReplacements;
                }
                
                addLog(`      ð ${values.length} valeurs Ã  injecter: [${values.map(v => (v * 100).toFixed(1) + '%').join(', ')}]`, 'info');
                
                if (values.length === 0) {
                    addLog(`      â Aucune donnÃ©e valide pour ${chartType}`, 'error');
                    return xmlContent;
                }
                
                // NOUVELLE VALIDATION: VÃ©rifier que le nombre de valeurs correspond au type de graphique
                const expectedValuesCount = getExpectedValuesCount(chartType);
                if (expectedValuesCount > 0 && values.length !== expectedValuesCount) {
                    addLog(`      â ï¸ Nombre de valeurs inattendu pour ${chartType}: ${values.length} au lieu de ${expectedValuesCount}`, 'warning');
                    addLog(`      ð Continuation malgrÃ© l'Ã©cart...`, 'info');
                }
                
                let modifiedXml = xmlContent;
                let totalModifications = 0;
                
                // APPROCHE STRICTE: EmpÃªcher le mÃ©lange des donnÃ©es en utilisant une validation stricte
                addLog(`      ð VALIDATION STRICTE POUR ÃVITER LE MÃLANGE DES DONNÃES`, 'info');
                
                // NOUVELLE APPROCHE: Utiliser le contexte d'appel pour dÃ©terminer si ce graphique doit Ãªtre modifiÃ©
                const shouldModifyChart = shouldModifyThisChart(xmlContent, chartType);
                addLog(`      ð Ce graphique doit-il Ãªtre modifiÃ© pour ${chartType}? ${shouldModifyChart ? 'OUI' : 'NON'}`, 'info');
                
                if (!shouldModifyChart) {
                    addLog(`      ð« Graphique ignorÃ© - Pas de modification pour Ã©viter le mÃ©lange des donnÃ©es`, 'warning');
                    return xmlContent;
                }
                
                addLog(`      â Graphique validÃ© - Application des donnÃ©es ${chartType}`, 'success');
                    
                    // DEBUG: Afficher la structure XML pour comprendre le problÃ¨me
                addLog(`      ð DEBUG: Analyse de la structure XML pour ${chartType}...`, 'info');
                
                // Chercher toutes les balises <c:v> dans le XML
                const allVTags = modifiedXml.match(/<c:v>[^<]*<\/c:v>/g) || [];
                addLog(`      ð Balises <c:v> trouvÃ©es: ${allVTags.length}`, 'info');
                allVTags.slice(0, 10).forEach((tag, index) => {
                    addLog(`        ${index + 1}. ${tag}`, 'info');
                });
                
                // Chercher toutes les balises <c:val> dans le XML
                const allValTags = modifiedXml.match(/<c:val>[^<]*<\/c:val>/g) || [];
                addLog(`      ð Balises <c:val> trouvÃ©es: ${allValTags.length}`, 'info');
                allValTags.slice(0, 10).forEach((tag, index) => {
                    addLog(`        ${index + 1}. ${tag}`, 'info');
                });
                
                // DEBUG ÃTENDU: Chercher d'autres patterns de valeurs numÃ©riques
                const numericPatterns = [
                    /<c:pt[^>]*>[\s\S]*?<c:v>([0-9.]+)<\/c:v>[\s\S]*?<\/c:pt>/g,
                    /<c:numRef>[\s\S]*?<c:numCache>[\s\S]*?<c:pt[^>]*>[\s\S]*?<c:v>([0-9.]+)<\/c:v>[\s\S]*?<\/c:pt>[\s\S]*?<\/c:numCache>[\s\S]*?<\/c:numRef>/g,
                    /<c:val>([0-9.]+)<\/c:val>/g,
                    /<c:v>([0-9.]+)<\/c:v>/g
                ];
                
                numericPatterns.forEach((pattern, index) => {
                    const matches = modifiedXml.match(pattern);
                    if (matches && matches.length > 0) {
                        addLog(`      ð Pattern ${index + 1} trouvÃ©: ${matches.length} occurrences`, 'info');
                        matches.slice(0, 5).forEach((match, matchIndex) => {
                            addLog(`        ${matchIndex + 1}. ${match.substring(0, 100)}...`, 'info');
                        });
                    }
                });
                
                // DEBUG: Afficher un Ã©chantillon du XML pour voir la structure
                const xmlSample = modifiedXml.substring(0, 2000);
                addLog(`      ð Ãchantillon XML (2000 caractÃ¨res):`, 'info');
                addLog(`      ${xmlSample.replace(/\n/g, ' ').substring(0, 500)}...`, 'info');
                
                // APPROCHE ULTRA-AGRESSIVE: Chercher TOUTES les valeurs numÃ©riques dans le XML
                addLog(`      ð RECHERCHE ULTRA-AGRESSIVE DE VALEURS NUMÃRIQUES...`, 'info');
                
                // Chercher toutes les valeurs numÃ©riques possibles
                const allNumericValues = modifiedXml.match(/\b(0\.\d+)\b/g) || [];
                addLog(`      ð Valeurs numÃ©riques trouvÃ©es: ${allNumericValues.length}`, 'info');
                allNumericValues.slice(0, 10).forEach((value, index) => {
                    addLog(`        ${index + 1}. ${value}`, 'info');
                });
                
                // APPROCHE 1: Modifier toutes les valeurs <c:v> de maniÃ¨re sÃ©quentielle
                const allValuesPattern = /<c:v>([0-9.]+)<\/c:v>/g;
                let matchCount = 0;
                
                modifiedXml = modifiedXml.replace(allValuesPattern, (match, currentValue) => {
                    if (matchCount < values.length) {
                        const newValue = values[matchCount];
                        addLog(`        â Valeur ${chartType} ${matchCount + 1}: ${currentValue} â ${newValue} (${(newValue * 100).toFixed(1)}%)`, 'success');
                        matchCount++;
                        totalModifications++;
                        return `<c:v>${newValue}</c:v>`;
                    }
                    return match;
                });
                
                // APPROCHE 2: Si pas de balises <c:v>, essayer de remplacer directement les valeurs numÃ©riques
                if (totalModifications === 0 && allNumericValues.length > 0) {
                    addLog(`      ð APPROCHE DIRECTE: Remplacement des valeurs numÃ©riques...`, 'info');
                    
                    // Trier les valeurs par ordre dÃ©croissant pour Ã©viter les conflits
                    const sortedValues = [...values].sort((a, b) => b - a);
                    let directMatchCount = 0;
                    
                    // Remplacer les valeurs une par une
                    for (let i = 0; i < Math.min(sortedValues.length, allNumericValues.length); i++) {
                        const oldValue = allNumericValues[i];
                        const newValue = sortedValues[i];
                        
                        if (parseFloat(oldValue) !== newValue) { // Ãviter de remplacer par la mÃªme valeur
                            const beforeCount = (modifiedXml.match(new RegExp(`\\b${oldValue}\\b`, 'g')) || []).length;
                            if (beforeCount > 0) {
                                modifiedXml = modifiedXml.replace(new RegExp(`\\b${oldValue}\\b`, 'g'), newValue.toString());
                                addLog(`        â Valeur directe ${i + 1}: ${oldValue} â ${newValue} (${(newValue * 100).toFixed(1)}%)`, 'success');
                                directMatchCount += beforeCount;
                            }
                        }
                    }
                    
                    totalModifications += directMatchCount;
                }
                
                // APPROCHE SPÃCIALE POUR GRAPH_PROV: GÃ©rer la valeur "Autre" sÃ©parÃ©ment
                if (chartType === 'GRAPH_PROV') {
                    addLog(`      ð GESTION SPÃCIALE DE LA VALEUR "AUTRE"...`, 'info');
                    
                    // Calculer la valeur "Autre" (ce qui reste pour arriver Ã  100%)
                    const totalVilles = values.reduce((sum, val) => sum + val, 0);
                    const valeurAutre = Math.max(0, 1 - totalVilles); // 1 = 100%
                    
                    addLog(`      ð Valeur "Autre" calculÃ©e: ${(valeurAutre * 100).toFixed(1)}%`, 'info');
                    
                    // Chercher et remplacer la valeur 0.70 (70% du template) par la vraie valeur "Autre"
                    const templateAutreValue = '0.70';
                    const beforeCount = (modifiedXml.match(new RegExp(`\\b${templateAutreValue}\\b`, 'g')) || []).length;
                    if (beforeCount > 0) {
                        modifiedXml = modifiedXml.replace(new RegExp(`\\b${templateAutreValue}\\b`, 'g'), valeurAutre.toString());
                        addLog(`        â Valeur "Autre": ${templateAutreValue} â ${valeurAutre} (${(valeurAutre * 100).toFixed(1)}%)`, 'success');
                        totalModifications += beforeCount;
                    } else {
                        addLog(`        â ï¸ Valeur template "Autre" (0.70) non trouvÃ©e dans le XML`, 'warning');
                        
                        // Chercher d'autres valeurs possibles pour "Autre"
                        const autresValeurs = ['0.7', '0.700', '70', '0.69', '0.71'];
                        for (const autreVal of autresValeurs) {
                            const count = (modifiedXml.match(new RegExp(`\\b${autreVal}\\b`, 'g')) || []).length;
                            if (count > 0) {
                                modifiedXml = modifiedXml.replace(new RegExp(`\\b${autreVal}\\b`, 'g'), valeurAutre.toString());
                                addLog(`        â Valeur "Autre" alternative: ${autreVal} â ${valeurAutre} (${(valeurAutre * 100).toFixed(1)}%)`, 'success');
                                totalModifications += count;
                                break;
                            }
                        }
                    }
                }
                
                // NOUVELLE APPROCHE: Modifier aussi les lÃ©gendes dans le XML (pas seulement les valeurs)
                if (chartType === 'GRAPH_PROV') {
                    addLog(`      ðï¸ REMPLACEMENT DES LÃGENDES DANS LE XML (pas Excel embarquÃ©)...`, 'info');
                    
                    // RecrÃ©er le mapping des placeholders pour cette fonction
                    const communePattern = /([^:]+): ([\d.]+)%/g;
                    const communeMatches = [...dataString.matchAll(communePattern)];
                    const cityMatches = communeMatches.filter(match => 
                        !match[1].toLowerCase().includes('autres') && 
                        !match[1].toLowerCase().includes('autre')
                    );
                    
                    const cityNames = cityMatches.map(match => {
                        let cleanCityName = match[1].trim();
                        cleanCityName = cleanCityName.replace(/^,\s*/, '');
                        cleanCityName = cleanCityName.replace(/,\s*$/, '');
                        cleanCityName = cleanCityName.replace(/,/g, '');
                        cleanCityName = cleanCityName.replace(/\s+/g, ' ');
                        cleanCityName = cleanCityName.trim();
                        return cleanCityName;
                    });
                    
                    const legendPlaceholderMapping = {};
                    cityNames.forEach((cityName, index) => {
                        const placeholderKey = `{Ville${index + 1}}`;
                        legendPlaceholderMapping[placeholderKey] = cityName;
                        addLog(`        ðºï¸ Mapping lÃ©gende: ${placeholderKey} â "${cityName}"`, 'info');
                    });
                    
                    // Remplacer les placeholders de lÃ©gende dans le XML
                    for (const [placeholder, cityName] of Object.entries(legendPlaceholderMapping)) {
                        // Recherche agressive dans tout le XML
                        const beforeCount = (modifiedXml.match(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g')) || []).length;
                        if (beforeCount > 0) {
                            modifiedXml = modifiedXml.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                            addLog(`        ðï¸ LÃ©gende XML: ${placeholder} â "${cityName}" (${beforeCount} occurrences)`, 'success');
                            totalModifications += beforeCount;
                        }
                    }
                }
                
                    // Si pas assez de valeurs trouvÃ©es avec <c:v>, essayer avec <c:val>
                if (totalModifications === 0) {
                    addLog(`      ð Tentative avec les balises <c:val>...`, 'info');
                    const valPattern = /<c:val>([^<]*)<\/c:val>/g;
                    matchCount = 0;
                    
                    modifiedXml = modifiedXml.replace(valPattern, (match, currentValue) => {
                        if (matchCount < values.length) {
                            const newValue = values[matchCount];
                                addLog(`        â Valeur <c:val> ${chartType} ${matchCount + 1}: ${currentValue} â ${newValue} (${(newValue * 100).toFixed(1)}%)`, 'success');
                            matchCount++;
                            totalModifications++;
                            return `<c:val>${newValue}</c:val>`;
                        }
                        return match;
                    });
                }
                
                addLog(`      ð ${totalModifications} valeurs XML modifiÃ©es au total`, 'info');
                return modifiedXml;
                
            } catch (error) {
                addLog(`      â Erreur mise Ã  jour XML ${chartType}: ${error.message}`, 'error');
                return xmlContent;
            }
        }

        // Fonction pour dÃ©tecter le type de graphique dans le XML
        function detectChartTypeInXml(xmlContent) {
            try {
                addLog(`      ð ANALYSE DÃTAILLÃE DU XML POUR DÃTECTION DE TYPE`, 'info');
                
                // Afficher un Ã©chantillon du XML pour debug
                const sampleLength = Math.min(1000, xmlContent.length);
                const xmlSample = xmlContent.substring(0, sampleLength);
                addLog(`      ð Ãchantillon XML (${sampleLength} caractÃ¨res):`, 'info');
                addLog(`      ${xmlSample.replace(/\n/g, ' ').substring(0, 300)}...`, 'info');
                
                // Chercher les identifiants de type de graphique dans le XML (PANE NAMING PowerPoint)
                if (xmlContent.includes('GRAPH_AGE')) {
                    addLog(`      â Identifiant GRAPH_AGE (PANE NAMING) trouvÃ©`, 'success');
                    return 'AGE';
                } else if (xmlContent.includes('GRAPH_CSP')) {
                    addLog(`      â Identifiant GRAPH_CSP (PANE NAMING) trouvÃ©`, 'success');
                    return 'CSP';
                } else if (xmlContent.includes('GRAPH_SEXE')) {
                    addLog(`      â Identifiant GRAPH_SEXE (PANE NAMING) trouvÃ©`, 'success');
                    return 'SEXE';
                } else if (xmlContent.includes('GRAPH_PROV')) {
                    // VÃ©rification supplÃ©mentaire : s'assurer que ce n'est pas un graphique CSP
                    if (xmlContent.includes('Cadres') || xmlContent.includes('EmployÃ©s') || xmlContent.includes('Ouvriers')) {
                        addLog(`      â ï¸ GRAPH_PROV contient des patterns CSP - TraitÃ© comme CSP`, 'warning');
                        return 'CSP';
                    }
                    addLog(`      â Identifiant GRAPH_PROV (PANE NAMING) trouvÃ© - TEST`, 'success');
                    return 'GRAPH_PROV';
                }
                
                // Chercher des patterns spÃ©cifiques dans les labels ou donnÃ©es
                if (xmlContent.includes('15-24 ans') || xmlContent.includes('25-34 ans') || xmlContent.includes('35-49 ans')) {
                    addLog(`      â Patterns d'Ã¢ge dÃ©tectÃ©s dans le XML`, 'success');
                    return 'AGE';
                } else if (xmlContent.includes('Agriculteurs') || xmlContent.includes('Cadres') || xmlContent.includes('EmployÃ©s')) {
                    addLog(`      â Patterns CSP dÃ©tectÃ©s dans le XML`, 'success');
                    return 'CSP';
                } else if (xmlContent.includes('Homme') || xmlContent.includes('Femme')) {
                    addLog(`      â Patterns de sexe (Homme/Femme) dÃ©tectÃ©s dans le XML`, 'success');
                    return 'SEXE';
                }
                
                addLog(`      â Aucun pattern de type de graphique dÃ©tectÃ©`, 'warning');
                return null; // Type non dÃ©tectÃ©
            } catch (error) {
                addLog(`      â Erreur dÃ©tection type graphique: ${error.message}`, 'error');
                return null;
            }
        }

        // Fonction pour dÃ©terminer si un graphique doit Ãªtre modifiÃ© (approche stricte)
        function shouldModifyThisChart(xmlContent, chartType) {
            try {
                addLog(`      ð ANALYSE STRICTE DU GRAPHIQUE POUR ${chartType}`, 'info');
                
                // 1. Chercher des identifiants explicites dans le XML (PANE NAMING PowerPoint)
                if (chartType === 'AGE' && xmlContent.includes('GRAPH_AGE')) {
                    addLog(`      â Identifiant GRAPH_AGE (PANE NAMING) trouvÃ©`, 'success');
                    return true;
                } else if (chartType === 'CSP' && xmlContent.includes('GRAPH_CSP')) {
                    addLog(`      â Identifiant GRAPH_CSP (PANE NAMING) trouvÃ©`, 'success');
                    return true;
                } else if (chartType === 'SEXE' && xmlContent.includes('GRAPH_SEXE')) {
                    addLog(`      â Identifiant GRAPH_SEXE (PANE NAMING) trouvÃ©`, 'success');
                    return true;
                } else if (chartType === 'GRAPH_PROV' && xmlContent.includes('GRAPH_PROV')) {
                    addLog(`      â Identifiant GRAPH_PROV (PANE NAMING) trouvÃ© - TEST`, 'success');
                    // VÃ©rification supplÃ©mentaire : s'assurer que ce n'est pas un graphique CSP
                    if (xmlContent.includes('Cadres') || xmlContent.includes('EmployÃ©s') || xmlContent.includes('Ouvriers')) {
                        addLog(`      â ï¸ GRAPH_PROV contient des patterns CSP - IgnorÃ© pour Ã©viter le conflit`, 'warning');
                        return false;
                    }
                    return true;
                }
                
                // 2. Chercher des patterns de donnÃ©es spÃ©cifiques
                if (chartType === 'AGE') {
                    const agePatterns = ['15-24 ans', '25-34 ans', '35-49 ans', '50-64 ans', '65 ans'];
                    const hasAgePattern = agePatterns.some(pattern => xmlContent.includes(pattern));
                    if (hasAgePattern) {
                        addLog(`      â Patterns d'Ã¢ge dÃ©tectÃ©s dans le XML`, 'success');
                        return true;
                    }
                    
                    // NOUVELLE APPROCHE: Chercher des patterns plus gÃ©nÃ©riques
                    const genericAgePatterns = ['ans', 'age', 'tranche', 'groupe'];
                    const hasGenericPattern = genericAgePatterns.some(pattern => xmlContent.toLowerCase().includes(pattern));
                    if (hasGenericPattern) {
                        addLog(`      â Patterns gÃ©nÃ©riques d'Ã¢ge dÃ©tectÃ©s dans le XML`, 'success');
                    return true;
                    }
                    
                    // APPROCHE CONSERVATRICE: Si aucun pattern spÃ©cifique, NE PAS modifier pour Ã©viter le mÃ©lange
                    addLog(`      â Aucun pattern d'Ã¢ge spÃ©cifique trouvÃ© - Graphique ignorÃ© pour Ã©viter le mÃ©lange`, 'warning');
                    return false;
                } else if (chartType === 'CSP') {
                    // VÃRIFICATION STRICTE: Ne pas appliquer CSP si c'est un graphique GRAPH_PROV
                    if (xmlContent.includes('GRAPH_PROV')) {
                        addLog(`      ð« GRAPH_PROV dÃ©tectÃ© - CSP ignorÃ© pour Ã©viter le mÃ©lange`, 'warning');
                        return false;
                    }
                    
                    // DEBUG: Analyser le contenu XML pour CSP
                    addLog(`      ð ANALYSE XML CSP - Ãchantillon:`, 'info');
                    const xmlSample = xmlContent.substring(0, 500).replace(/\n/g, ' ');
                    addLog(`      ${xmlSample}...`, 'info');
                    
                    const cspPatterns = [
                        'Cadres et professions intellectuelles sup.',
                        'Professions intermÃ©diaires',
                        'Artisans, commerÃ§ants et chefs d\'entreprise',
                        'EmployÃ©s',
                        'Ouvriers',
                        'Agriculteurs exploitants',
                        'ElÃ¨ves, Ã©tudiants, stagiaires',
                        'RetraitÃ©s',
                        'Autres personnes sans activitÃ© pro',
                        // Patterns partiels pour compatibilitÃ©
                        'Cadres', 'Artisans', 'Agriculteurs', 'Ãtudiants', 'EmployÃ©s', 'Ouvriers', 'RetraitÃ©s'
                    ];
                    const hasCspPattern = cspPatterns.some(pattern => xmlContent.includes(pattern));
                    if (hasCspPattern) {
                        addLog(`      â Patterns CSP dÃ©tectÃ©s dans le XML`, 'success');
                        return true;
                    }
                    
                    // NOUVELLE APPROCHE: Chercher des patterns plus gÃ©nÃ©riques pour CSP
                    const genericCspPatterns = ['profession', 'catÃ©gorie', 'socio', 'csp', 'mÃ©tier', 'emploi', 'travail'];
                    const hasGenericCspPattern = genericCspPatterns.some(pattern => xmlContent.toLowerCase().includes(pattern));
                    if (hasGenericCspPattern) {
                        addLog(`      â Patterns gÃ©nÃ©riques CSP dÃ©tectÃ©s dans le XML`, 'success');
                    return true;
                    }
                    
                    // NOUVELLE APPROCHE: Analyser le nombre de valeurs pour dÃ©tecter un graphique CSP
                    const valueCount = (xmlContent.match(/<c:v>([0-9.]+)<\/c:v>/g) || []).length;
                    if (valueCount >= 6 && valueCount <= 12) {
                        addLog(`      â Graphique CSP dÃ©tectÃ© par nombre de valeurs (${valueCount})`, 'success');
                        return true;
                    }
                    
                    // NOUVELLE APPROCHE: Chercher des patterns de graphique en barres horizontales (typique des CSP)
                    if (xmlContent.includes('<c:barChart') || xmlContent.includes('<c:barDir val="bar"')) {
                        addLog(`      â Graphique en barres dÃ©tectÃ© (typique des CSP)`, 'success');
                        return true;
                    }
                    
                    // APPROCHE CONSERVATRICE: Si aucun pattern spÃ©cifique, NE PAS modifier pour Ã©viter le mÃ©lange
                    addLog(`      â Aucun pattern CSP spÃ©cifique trouvÃ© - Graphique ignorÃ© pour Ã©viter le mÃ©lange`, 'warning');
                    return false;
                } else if (chartType === 'SEXE') {
                    // NOUVELLE LOGIQUE: SEXE = Homme/Femme uniquement
                    const sexePatterns = ['Homme', 'Femme', 'Masculin', 'FÃ©minin'];
                    const hasSexePattern = sexePatterns.some(pattern => xmlContent.includes(pattern));
                    if (hasSexePattern) {
                        addLog(`      â Patterns de sexe (Homme/Femme) dÃ©tectÃ©s dans le XML`, 'success');
                        return true;
                    }
                    
                    addLog(`      â Aucun pattern de sexe trouvÃ© - Graphique ignorÃ©`, 'warning');
                    return false;
                }
                
                // 3. APPROCHE CONSERVATRICE: Si aucun pattern spÃ©cifique trouvÃ©, ne pas modifier
                addLog(`      â Aucun pattern spÃ©cifique Ã  ${chartType} trouvÃ© - Graphique ignorÃ© pour Ã©viter le mÃ©lange`, 'warning');
                return false;
                
            } catch (error) {
                addLog(`      â Erreur validation graphique: ${error.message}`, 'error');
                return false; // En cas d'erreur, ne pas modifier pour Ã©viter les problÃ¨mes
            }
        }

        // Fonction pour parser les donnÃ©es de la colonne "RÃ©seau"
        function parseNetworkData(networkString) {
            try {
                addLog(`    ð PARSING DU RÃSEAU: "${networkString}"`, 'info');
                
                // Format attendu: "Vannes - temporaire - 7 jours - flanc_gauche - 40 faces"
                const parts = networkString.split(' - ');
                
                if (parts.length >= 5) {
                    const ville = parts[0].trim();
                    const type = parts[1].trim(); // temporaire
                    const duree = parts[2].trim(); // 7 jours ou 14 jours
                    const face = parts[3].trim(); // flanc_gauche, flanc_droit, arriere
                    const faces = parts[4].trim(); // 40 faces
                    
                    // Calculer la semaine (pour l'instant, on utilise la semaine actuelle)
                    const currentWeek = getCurrentWeek();
                    
                    // Normaliser les noms de face
                    const normalizedFace = normalizeFaceName(face);
                    
                    return {
                        ville: ville,
                        type: type,
                        duree: duree,
                        face: normalizedFace,
                        faces: faces,
                        semaine: currentWeek,
                        original: networkString
                    };
                } else {
                    addLog(`    â ï¸ Format rÃ©seau non reconnu: ${networkString}`, 'warning');
                    return {
                        ville: 'Inconnue',
                        type: 'standard',
                        duree: '7 jours',
                        face: 'standard',
                        faces: 'standard',
                        semaine: getCurrentWeek(),
                        original: networkString
                    };
                }
            } catch (error) {
                addLog(`    â Erreur parsing rÃ©seau: ${error.message}`, 'error');
                return {
                    ville: 'Erreur',
                    type: 'standard',
                    duree: '7 jours',
                    face: 'standard',
                    faces: 'standard',
                    semaine: getCurrentWeek(),
                    original: networkString
                };
            }
        }

        // Fonction pour normaliser les noms de face
        function normalizeFaceName(face) {
            const faceMap = {
                'flanc_gauche': 'Flanc Gauche',
                'flanc_droit': 'Flanc Droit',
                'arriere': 'ArriÃ¨re',
                'flanc gauche': 'Flanc Gauche',
                'flanc droit': 'Flanc Droit',
                'arriÃ¨re': 'ArriÃ¨re'
            };
            
            const normalized = faceMap[face.toLowerCase()] || face;
            addLog(`    ð Face normalisÃ©e: "${face}" â "${normalized}"`, 'info');
            return normalized;
        }

        // Fonction pour calculer la semaine actuelle
        function getCurrentWeek() {
            const now = new Date();
            const start = new Date(now.getFullYear(), 0, 1);
            const days = Math.floor((now - start) / (24 * 60 * 60 * 1000));
            const weekNumber = Math.ceil((days + start.getDay() + 1) / 7);
            return Math.min(weekNumber, 52); // Max 52 semaines
        }

        // Fonction pour crÃ©er la hiÃ©rarchie de dossiers
        function createFileHierarchy(networkData, fileName) {
            try {
                // Structure: ANNEE - Rapports d'audience Buster/SEMAINE/VILLE/FACE/VERSION/fichier
                const currentYear = new Date().getFullYear();
                const parentFolder = `${currentYear} - Rapports d'audience Buster`;
                const semaine = `Semaine ${networkData.semaine}`;
                const ville = networkData.ville;
                const face = networkData.face;
                const version = networkData.duree === '7 jours' ? 'Version 7 jours' : 'Version 14 jours';
                
                const filePath = `${parentFolder}/${semaine}/${ville}/${face}/${version}/${fileName}`;
                
                addLog(`    ð Chemin crÃ©Ã©: ${filePath}`, 'info');
                return filePath;
                
            } catch (error) {
                addLog(`    â Erreur crÃ©ation hiÃ©rarchie: ${error.message}`, 'error');
                return fileName; // Fallback
            }
        }

        // Fonction pour traiter le fichier Excel embarquÃ© pour GRAPH_PROV
        async function processEmbeddedExcelForGraphProv(zip, slideFile, templateData, row, excelData) {
            try {
                addLog(`    ð RECHERCHE DU FICHIER EXCEL EMBARQUÃ POUR GRAPH_PROV...`, 'info');
                
                // 1. Chercher les fichiers Excel embarquÃ©s
                const embeddedFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('embeddings/') && relativePath.endsWith('.xlsx')) {
                        embeddedFiles.push(relativePath);
                    }
                });
                
                addLog(`    ð ${embeddedFiles.length} fichiers Excel embarquÃ©s trouvÃ©s`, 'info');
                
                // 2. Pour chaque fichier Excel embarquÃ©, chercher GRAPH_PROV
                for (const excelFile of embeddedFiles) {
                    try {
                        addLog(`    ð Analyse de ${excelFile}...`, 'info');
                        
                        // Lire le fichier Excel embarquÃ©
                        const embeddedExcelBuffer = await zip.file(excelFile).async('arraybuffer');
                        const embeddedWorkbook = XLSX.read(embeddedExcelBuffer, { type: 'array' });
                        
                        // Chercher dans toutes les feuilles
                        let foundInSheet = false;
                        for (const sheetName of Object.keys(embeddedWorkbook.Sheets)) {
                            const sheet = embeddedWorkbook.Sheets[sheetName];
                            const sheetContent = XLSX.utils.sheet_to_txt(sheet);
                            
                            if (sheetContent.includes('GRAPH_PROV')) {
                                addLog(`    â GRAPH_PROV trouvÃ© dans ${excelFile}, feuille "${sheetName}"`, 'success');
                                foundInSheet = true;
                                
                                // Modifier les donnÃ©es dans cette feuille
                                const modified = await updateExcelSheetForGraphProv(sheet, templateData, row, excelData);
                                
                                if (modified) {
                                    // Sauvegarder le fichier Excel modifiÃ©
                                    const modifiedBuffer = XLSX.write(embeddedWorkbook, { type: 'array', bookType: 'xlsx' });
                                    zip.file(excelFile, modifiedBuffer);
                                    addLog(`    â Fichier Excel ${excelFile} modifiÃ© avec succÃ¨s`, 'success');
                                    return true;
                                }
                            }
                            else if (sheetContent.includes('GRAPHIQUE PROVENANCE')) {
                                addLog(`    ð "GRAPHIQUE PROVENANCE" trouvÃ© dans ${excelFile}, feuille "${sheetName}"`, 'warning');
                                foundInSheet = true;
                                
                                // Modifier les donnÃ©es dans cette feuille
                                const modified = await updateExcelSheetForGraphProv(sheet, templateData, row, excelData);
                                
                                if (modified) {
                                    // Sauvegarder le fichier Excel modifiÃ©
                                    const modifiedBuffer = XLSX.write(embeddedWorkbook, { type: 'array', bookType: 'xlsx' });
                                    zip.file(excelFile, modifiedBuffer);
                                    addLog(`    â Fichier Excel ${excelFile} modifiÃ© avec succÃ¨s`, 'success');
                                    return true;
                                }
                            }
                        }
                        
                        if (!foundInSheet) {
                            addLog(`    â GRAPH_PROV non trouvÃ© dans ${excelFile}`, 'info');
                        }
                        
                    } catch (error) {
                        addLog(`    â ï¸ Erreur traitement ${excelFile}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`    â Aucun fichier Excel embarquÃ© contenant GRAPH_PROV trouvÃ©`, 'warning');
                return false;
                
            } catch (error) {
                addLog(`    â Erreur recherche Excel embarquÃ©: ${error.message}`, 'error');
                return false;
            }
        }

        // Fonction pour mettre Ã  jour une feuille Excel pour GRAPH_PROV
        async function updateExcelSheetForGraphProv(sheet, templateData, row, excelData) {
            try {
                addLog(`      ð MISE Ã JOUR DE LA FEUILLE EXCEL POUR GRAPH_PROV`, 'info');
                
                // 1. Obtenir les donnÃ©es de provenance
                const graphProvData = await processGraphProvData(row, excelData);
                if (!graphProvData) {
                    addLog(`      â Impossible d'obtenir les donnÃ©es de provenance`, 'error');
                    return false;
                }
                
                addLog(`      ð DonnÃ©es de provenance: ${graphProvData}`, 'info');
                
                // 2. Parser les donnÃ©es
                const communePattern = /([^:]+): ([\d.]+)%/g;
                const communeMatches = [...graphProvData.matchAll(communePattern)];
                
                // Filtrer pour exclure "Autres" des villes (garder seulement les vraies villes)
                const cityMatches = communeMatches.filter(match => 
                    !match[1].toLowerCase().includes('autres') && 
                    !match[1].toLowerCase().includes('autre')
                );
                
                const values = cityMatches.map(match => parseFloat(match[2]) / 100); // Ne pas multiplier par 10
                
                addLog(`      ð ${values.length} valeurs Ã  injecter: [${values.map(v => (v * 100).toFixed(1) + '%').join(', ')}]`, 'info');
                
                // 3. ANALYSER LA STRUCTURE RÃELLE DU FICHIER EXCEL EMBARQUÃ
                addLog(`      ð ANALYSE DE LA STRUCTURE EXCEL EMBARQUÃ...`, 'info');
                
                // Afficher toutes les cellules non-vides pour comprendre la structure
                const allCells = [];
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined) {
                        allCells.push({
                            ref: cellRef,
                            value: cell.v,
                            type: typeof cell.v
                        });
                    }
                }
                
                addLog(`      ð ${allCells.length} cellules non-vides trouvÃ©es`, 'info');
                
                // Afficher les premiÃ¨res cellules pour debug
                const sampleCells = allCells.slice(0, 20);
                addLog(`      ð Ãchantillon des cellules:`, 'info');
                sampleCells.forEach(cell => {
                    addLog(`        ${cell.ref}: "${cell.value}" (${cell.type})`, 'info');
                });
                
                // 4. NOUVELLE APPROCHE: Recherche intelligente des cellules de labels
                let modified = false;
                let valueIndex = 0;
                let labelIndex = 0;
                
                // Extraire les noms des villes (seulement les vraies villes)
                const cityNames = cityMatches.map(match => {
                    // Nettoyer les noms de villes : supprimer les virgules et espaces
                    let cleanCityName = match[1].trim();
                    cleanCityName = cleanCityName.replace(/^,\s*/, ''); // Supprimer virgule au dÃ©but
                    cleanCityName = cleanCityName.replace(/,\s*$/, ''); // Supprimer virgule Ã  la fin
                    cleanCityName = cleanCityName.replace(/,/g, ''); // Supprimer toutes les autres virgules
                    cleanCityName = cleanCityName.replace(/\s+/g, ' '); // Remplacer les espaces multiples par un seul
                    cleanCityName = cleanCityName.trim(); // Supprimer les espaces en dÃ©but/fin
                    return cleanCityName;
                });
                addLog(`      ðï¸ Noms de villes Ã  injecter: [${cityNames.join(', ')}]`, 'info');
                
                // STRATÃGIE 1: Chercher et remplacer les placeholders avec accolades {VilleX}
                addLog(`      ð Recherche des placeholders avec accolades {VilleX}...`, 'info');
                
                // CrÃ©er un mapping des placeholders vers les vrais noms de villes
                const placeholderMapping = {};
                cityNames.forEach((cityName, index) => {
                    const placeholderKey = `{Ville${index + 1}}`; // Ville1, Ville2, Ville3, Ville4, Ville5, Ville6
                    placeholderMapping[placeholderKey] = cityName;
                    addLog(`        ðºï¸ Mapping: ${placeholderKey} â "${cityName}"`, 'info');
                });
                
                // Ajouter aussi les variations possibles (au cas oÃ¹)
                cityNames.forEach((cityName, index) => {
                    const variations = [
                        `{Ville${index + 1}}`,
                        `{ville${index + 1}}`,
                        `{VILLE${index + 1}}`,
                        `Ville${index + 1}`,
                        `ville${index + 1}`,
                        `VILLE${index + 1}`
                    ];
                    
                    variations.forEach(variation => {
                        if (!placeholderMapping[variation]) {
                            placeholderMapping[variation] = cityName;
                        }
                    });
                });
                
                // Parcourir toutes les cellules pour remplacer les placeholders
                addLog(`      ð Recherche dans ${Object.keys(sheet).length} cellules...`, 'info');
                
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                        const cellValue = cell.v.toString();
                        
                        // VÃ©rifier si cette cellule contient un placeholder avec accolades
                        for (const [placeholder, cityName] of Object.entries(placeholderMapping)) {
                            if (cellValue.includes(placeholder)) {
                                const oldLabel = cell.v;
                                cell.v = cellValue.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                                addLog(`        ðï¸ Placeholder ${cellRef}: "${oldLabel}" â "${cell.v}"`, 'success');
                                modified = true;
                                break; // Sortir de la boucle des placeholders pour cette cellule
                            }
                        }
                    }
                }
                
                // APPROCHE SPÃCIFIQUE: Chercher dans les cellules qui pourraient contenir les lÃ©gendes
                addLog(`      ð Recherche spÃ©cifique des cellules de lÃ©gende...`, 'info');
                
                // Chercher les cellules qui contiennent des patterns de lÃ©gende
                const legendCellPatterns = ['Ville', 'ville', 'City', 'city', 'Legend', 'legend'];
                
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                        const cellValue = cell.v.toString();
                        
                        // Si cette cellule contient un pattern de lÃ©gende ET un placeholder
                        const hasLegendPattern = legendCellPatterns.some(pattern => 
                            cellValue.toLowerCase().includes(pattern.toLowerCase())
                        );
                        
                        if (hasLegendPattern) {
                            addLog(`        ð Cellule de lÃ©gende potentielle ${cellRef}: "${cellValue}"`, 'info');
                            
                            // Essayer de remplacer les placeholders dans cette cellule
                            for (const [placeholder, cityName] of Object.entries(placeholderMapping)) {
                                if (cellValue.includes(placeholder)) {
                                    const oldLabel = cell.v;
                                    cell.v = cellValue.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), cityName);
                                    addLog(`        ðï¸ LÃ©gende ${cellRef}: "${oldLabel}" â "${cell.v}"`, 'success');
                                    modified = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // STRATÃGIE 2: Chercher les cellules contenant des patterns de labels gÃ©nÃ©riques (fallback)
                const labelPatterns = [
                    'ville', 'city', 'commune', 'municipalitÃ©', 'localitÃ©', 'lieu',
                    'Ville', 'City', 'Commune', 'MunicipalitÃ©', 'LocalitÃ©', 'Lieu',
                    'ville1', 'ville2', 'ville3', 'ville4', 'ville5', 'ville6',
                    'Ville1', 'Ville2', 'Ville3', 'Ville4', 'Ville5', 'Ville6'
                ];
                
                addLog(`      ð Recherche des cellules de labels avec patterns gÃ©nÃ©riques (fallback)...`, 'info');
                
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                        const cellValue = cell.v.toString();
                        
                        // VÃ©rifier si cette cellule correspond Ã  un pattern de label
                        const isLabelCell = labelPatterns.some(pattern => 
                            cellValue.toLowerCase().includes(pattern.toLowerCase())
                        );
                        
                        if (isLabelCell && labelIndex < cityNames.length) {
                            const oldLabel = cell.v;
                            cell.v = cityNames[labelIndex];
                            addLog(`        ðï¸ Label ${cellRef}: "${oldLabel}" â "${cell.v}" (pattern dÃ©tectÃ©)`, 'success');
                            labelIndex++;
                            modified = true;
                        }
                    }
                }
                
                // STRATÃGIE 2: Si pas assez de labels trouvÃ©s, chercher les cellules vides ou avec des valeurs par dÃ©faut
                if (labelIndex < cityNames.length) {
                    addLog(`      ð Recherche des cellules vides ou par dÃ©faut pour les labels restants...`, 'info');
                    
                    for (const cellRef in sheet) {
                        const cell = sheet[cellRef];
                        if (cell && cell.v !== undefined && typeof cell.v === 'string') {
                            const cellValue = cell.v.toString().trim();
                            
                            // Chercher des cellules vides, avec des espaces, ou des valeurs gÃ©nÃ©riques
                            if ((cellValue === '' || cellValue === ' ' || cellValue === 'Ville' || 
                                 cellValue === 'ville' || cellValue === 'City' || cellValue === 'city' ||
                                 cellValue.match(/^ville\s*\d*$/i) || cellValue.match(/^city\s*\d*$/i)) &&
                                labelIndex < cityNames.length) {
                                
                                const oldLabel = cell.v;
                                cell.v = cityNames[labelIndex];
                                addLog(`        ðï¸ Label ${cellRef}: "${oldLabel}" â "${cell.v}" (cellule gÃ©nÃ©rique)`, 'success');
                                labelIndex++;
                                modified = true;
                            }
                        }
                    }
                }
                
                // STRATÃGIE 3: Modifier les valeurs numÃ©riques (comme avant)
                addLog(`      ð Modification des valeurs numÃ©riques...`, 'info');
                for (const cellRef in sheet) {
                    const cell = sheet[cellRef];
                    if (cell && cell.v !== undefined && typeof cell.v === 'number' && cell.v > 0 && cell.v < 1) {
                        // C'est une valeur dÃ©cimale (probablement une donnÃ©e de graphique)
                        if (valueIndex < values.length) {
                            const oldValue = cell.v;
                            cell.v = values[valueIndex];
                            addLog(`        ð Valeur ${cellRef}: ${oldValue} â ${cell.v} (${(cell.v * 100).toFixed(1)}%)`, 'success');
                            valueIndex++;
                            modified = true;
                        }
                    }
                }
                
                if (modified) {
                    addLog(`      â ${valueIndex} valeurs et ${labelIndex} labels modifiÃ©s dans la feuille Excel`, 'success');
                } else {
                    addLog(`      â ï¸ Aucune valeur ou label modifiÃ© dans la feuille Excel`, 'warning');
                    addLog(`      ð¡ Conseil: VÃ©rifiez la structure du fichier Excel embarquÃ© dans PowerPoint`, 'info');
                }
                
                return modified;
                
            } catch (error) {
                addLog(`      â Erreur mise Ã  jour feuille Excel: ${error.message}`, 'error');
                return false;
            }
        }

        // Fonction pour traiter les graphiques dans les slides (fallback)
        async function processChartsInSlides(zip, templateData, row = null, excelData = null) {
            try {
                addLog('ð RECHERCHE DES GRAPHIQUES DANS LES SLIDES', 'info');
                
                const slideFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                        slideFiles.push(relativePath);
                    }
                });
                
                addLog(`ð ${slideFiles.length} slides Ã  analyser`, 'info');
                
                let graphiquesTrouves = 0;
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zip.file(slideFile).async('string');
                        
                        if (slideContent.includes('GRAPH_AGE') || slideContent.includes('GRAPH_CSP') || slideContent.includes('GRAPH_PROV')) {
                            addLog(`  â Graphiques trouvÃ©s dans ${slideFile}`, 'success');
                            
                            // Traitement spÃ©cial pour GRAPH_PROV dans les slides
                            if (slideContent.includes('GRAPH_PROV')) {
                                addLog(`  ðï¸ TRAITEMENT GRAPH_PROV dans ${slideFile} (XML uniquement)`, 'info');
                                
                                // APPROCHE XML UNIQUEMENT: Modifier directement le contenu XML de la slide
                                addLog(`  ð Modification XML de la slide pour GRAPH_PROV...`, 'info');
                                const modifiedContent = await processChartXmlContent(slideContent, templateData, row, excelData);
                                
                                if (modifiedContent !== slideContent) {
                                    zip.file(slideFile, modifiedContent);
                                    addLog(`  â Slide GRAPH_PROV modifiÃ©e (XML): ${slideFile}`, 'success');
                                    graphiquesTrouves++;
                                } else {
                                    addLog(`  â ï¸ Aucune modification XML pour GRAPH_PROV dans ${slideFile}`, 'warning');
                                }
                            } else {
                                // Traitement normal pour les autres graphiques
                                const modifiedContent = await processChartXmlContent(slideContent, templateData, row, excelData);
                                
                                if (modifiedContent !== slideContent) {
                                    zip.file(slideFile, modifiedContent);
                                    addLog(`  â Slide modifiÃ©e: ${slideFile}`, 'success');
                                    graphiquesTrouves++;
                                }
                            }
                        }
                    } catch (error) {
                        addLog(`  â ï¸ Erreur slide ${slideFile}: ${error.message}`, 'warning');
                    }
                }
                
                return graphiquesTrouves;
                
            } catch (error) {
                addLog(`â Erreur traitement slides: ${error.message}`, 'error');
                return 0;
            }
        }

        // Fonction pour traiter les fichiers Excel embarquÃ©s (version XML)
        async function processEmbeddedExcelChart(zip, chartFile, templateData) {
            try {
                addLog(`  ð TRAITEMENT VIA XML: ${chartFile}`, 'info');
                addLog(`  ð DonnÃ©es disponibles: AGE="${templateData['AGE']}", SOCIO-PRO="${templateData['SOCIO-PRO']}", SEXE="${templateData['SEXE']}"`, 'info');
                
                // Cette fonction est maintenant gÃ©rÃ©e par processEmbeddedCharts via XML
                addLog(`  â Traitement XML effectuÃ© dans processEmbeddedCharts`, 'success');
                return true;
                
            } catch (error) {
                addLog(`  â Erreur traitement graphique ${chartFile}: ${error.message}`, 'error');
                return false;
            }
        }

        // Fonction pour forcer la mise Ã  jour des graphiques dans PowerPoint
        async function forceChartRefresh(zip, chartFile) {
            try {
                addLog(`    ð FORCE LA MISE Ã JOUR DES GRAPHIQUES...`, 'info');
                
                // Parcourir les slides pour trouver les graphiques liÃ©s Ã  ce fichier Excel
                const slideFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                        slideFiles.push(relativePath);
                    }
                });
                
                addLog(`    ð ${slideFiles.length} slides Ã  analyser pour forcer la mise Ã  jour`, 'info');
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zip.file(slideFile).async('string');
                        
                        // Chercher les rÃ©fÃ©rences Ã  ce fichier Excel dans la slide
                        if (slideContent.includes(chartFile) || slideContent.includes('embeddings/') || 
                            slideContent.includes('GRAPH_AGE') || slideContent.includes('GRAPH_CSP') || 
                            slideContent.includes('GRAPH_PROV')) {
                            addLog(`      ð Graphique trouvÃ© dans ${slideFile}`, 'info');
                            
                            // Modifier le contenu XML pour forcer la mise Ã  jour
                            let modifiedSlideContent = slideContent;
                            
                            // 1. Ajouter un timestamp pour forcer la mise Ã  jour
                            const timestamp = Date.now();
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:chart xmlns:c="http:\/\/schemas\.openxmlformats\.org\/drawingml\/2006\/chart">/g,
                                `<c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" refresh="${timestamp}">`
                            );
                            
                            // 2. Forcer la mise Ã  jour des donnÃ©es
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:externalData r:id="[^"]*"/g,
                                `<c:externalData r:id="rId1" autoUpdate="1"`
                            );
                            
                            // 3. NOUVELLE APPROCHE: Modifier les mÃ©tadonnÃ©es du graphique
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:autoUpdate val="0"/g,
                                `<c:autoUpdate val="1"`
                            );
                            
                            // 4. Ajouter des attributs de rafraÃ®chissement
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<c:chart>/g,
                                `<c:chart autoUpdate="1" refresh="${timestamp}">`
                            );
                            
                            // 5. Modifier les relations pour forcer le rechargement
                            modifiedSlideContent = modifiedSlideContent.replace(
                                /<Relationship Id="[^"]*" Type="http:\/\/schemas\.openxmlformats\.org\/officeDocument\/2006\/relationships\/oleObject"/g,
                                `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject"`
                            );
                            
                            if (modifiedSlideContent !== slideContent) {
                                zip.file(slideFile, modifiedSlideContent);
                                addLog(`      â Slide ${slideFile} mise Ã  jour pour forcer le rafraÃ®chissement`, 'success');
                                addLog(`      ð§ Timestamp ajoutÃ©: ${timestamp}`, 'info');
                            }
                        }
                    } catch (error) {
                        addLog(`      â ï¸ Erreur mise Ã  jour slide ${slideFile}: ${error.message}`, 'warning');
                    }
                }
                
                // NOUVELLE APPROCHE: Modifier le fichier de relations
                await forceChartRelationsUpdate(zip);
                
                // NOUVELLE APPROCHE: CrÃ©er un fichier de mÃ©tadonnÃ©es pour forcer le rechargement
                await createChartMetadataFile(zip);
                
                addLog(`    â MISE Ã JOUR DES GRAPHIQUES FORCÃE`, 'success');
                
            } catch (error) {
                addLog(`    â Erreur force mise Ã  jour graphiques: ${error.message}`, 'error');
            }
        }

        // Fonction pour forcer la mise Ã  jour de tous les graphiques
        async function forceAllChartsRefresh(zip) {
            try {
                addLog(`    ð FORCE LA MISE Ã JOUR DE TOUS LES GRAPHIQUES...`, 'info');
                
                // 1. Parcourir tous les fichiers de graphiques
                const chartFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('charts/chart') && relativePath.endsWith('.xml')) {
                        chartFiles.push(relativePath);
                    }
                });
                
                addLog(`    ð ${chartFiles.length} fichiers de graphiques Ã  forcer`, 'info');
                
                for (const chartFile of chartFiles) {
                    try {
                        const chartContent = await zip.file(chartFile).async('string');
                        
                        // Ajouter des mÃ©tadonnÃ©es de rafraÃ®chissement
                        const timestamp = Date.now();
                        let modifiedChart = chartContent;
                        
                        // Forcer la mise Ã  jour des mÃ©tadonnÃ©es
                        modifiedChart = modifiedChart.replace(
                            /<c:chart xmlns:c="http:\/\/schemas\.openxmlformats\.org\/drawingml\/2006\/chart">/g,
                            `<c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" refresh="${timestamp}" autoUpdate="1">`
                        );
                        
                        // Ajouter des attributs de rafraÃ®chissement
                        modifiedChart = modifiedChart.replace(
                            /<c:chart>/g,
                            `<c:chart autoUpdate="1" refresh="${timestamp}">`
                        );
                        
                        if (modifiedChart !== chartContent) {
                            zip.file(chartFile, modifiedChart);
                            addLog(`      â Graphique ${chartFile} forcÃ© Ã  se rafraÃ®chir`, 'success');
                        }
                        
                    } catch (error) {
                        addLog(`      â ï¸ Erreur forÃ§age ${chartFile}: ${error.message}`, 'warning');
                    }
                }
                
                // 2. Forcer la mise Ã  jour des slides
                const slideFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                        slideFiles.push(relativePath);
                    }
                });
                
                for (const slideFile of slideFiles) {
                    try {
                        const slideContent = await zip.file(slideFile).async('string');
                        
                        if (slideContent.includes('<c:chart') || slideContent.includes('GRAPH_')) {
                            const timestamp = Date.now();
                            let modifiedSlide = slideContent;
                            
                            // Forcer la mise Ã  jour des graphiques dans les slides
                            modifiedSlide = modifiedSlide.replace(
                                /<c:chart xmlns:c="http:\/\/schemas\.openxmlformats\.org\/drawingml\/2006\/chart">/g,
                                `<c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" refresh="${timestamp}" autoUpdate="1">`
                            );
                            
                            if (modifiedSlide !== slideContent) {
                                zip.file(slideFile, modifiedSlide);
                                addLog(`      â Slide ${slideFile} forcÃ©e Ã  se rafraÃ®chir`, 'success');
                            }
                        }
                        
                    } catch (error) {
                        addLog(`      â ï¸ Erreur forÃ§age slide ${slideFile}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`    â MISE Ã JOUR FORCÃE DE TOUS LES GRAPHIQUES`, 'success');
                
            } catch (error) {
                addLog(`    â Erreur forÃ§age gÃ©nÃ©ral: ${error.message}`, 'error');
            }
        }

        // Fonction pour crÃ©er un fichier de mÃ©tadonnÃ©es pour forcer le rechargement
        async function createChartMetadataFile(zip) {
            try {
                addLog(`    ð CRÃATION FICHIER MÃTADONNÃES...`, 'info');
                
                const timestamp = Date.now();
                const metadataContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" 
                  Target="embeddings/Microsoft_Excel_Worksheet1.xlsx" 
                  autoUpdate="1" 
                  refresh="${timestamp}"/>
    <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" 
                  Target="embeddings/Microsoft_Excel_Worksheet2.xlsx" 
                  autoUpdate="1" 
                  refresh="${timestamp}"/>
</Relationships>`;
                
                // Ajouter le fichier de mÃ©tadonnÃ©es
                zip.file('embeddings/_rels/chart_metadata.rels', metadataContent);
                addLog(`      â Fichier mÃ©tadonnÃ©es crÃ©Ã© avec timestamp ${timestamp}`, 'success');
                
                // CrÃ©er aussi un fichier de cache pour forcer le rechargement
                const cacheContent = `<?xml version="1.0" encoding="UTF-8"?>
<ChartCache xmlns="http://schemas.microsoft.com/office/powerpoint/2010/main">
    <LastModified>${timestamp}</LastModified>
    <AutoUpdate>true</AutoUpdate>
    <RefreshOnOpen>true</RefreshOnOpen>
</ChartCache>`;
                
                zip.file('embeddings/chart_cache.xml', cacheContent);
                addLog(`      â Fichier cache crÃ©Ã©`, 'success');
                
            } catch (error) {
                addLog(`    â Erreur crÃ©ation mÃ©tadonnÃ©es: ${error.message}`, 'error');
            }
        }

        // Fonction pour forcer la mise Ã  jour des relations des graphiques
        async function forceChartRelationsUpdate(zip) {
            try {
                addLog(`    ð FORCE LA MISE Ã JOUR DES RELATIONS...`, 'info');
                
                // Modifier le fichier de relations des slides
                const relFiles = [];
                zip.forEach((relativePath, file) => {
                    if (relativePath.includes('slides/_rels/slide') && relativePath.endsWith('.rels')) {
                        relFiles.push(relativePath);
                    }
                });
                
                addLog(`    ð ${relFiles.length} fichiers de relations Ã  analyser`, 'info');
                
                for (const relFile of relFiles) {
                    try {
                        const relContent = await zip.file(relFile).async('string');
                        
                        if (relContent.includes('oleObject') || relContent.includes('embeddings/')) {
                            addLog(`      ð Relations de graphiques trouvÃ©es dans ${relFile}`, 'info');
                            
                            let modifiedRelContent = relContent;
                            
                            // Modifier les relations pour forcer le rechargement
                            modifiedRelContent = modifiedRelContent.replace(
                                /<Relationship Id="[^"]*" Type="http:\/\/schemas\.openxmlformats\.org\/officeDocument\/2006\/relationships\/oleObject" Target="[^"]*"/g,
                                `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject" Target="../embeddings/Microsoft_Excel_Worksheet1.xlsx"`
                            );
                            
                            if (modifiedRelContent !== relContent) {
                                zip.file(relFile, modifiedRelContent);
                                addLog(`      â Relations ${relFile} mises Ã  jour`, 'success');
                            }
                        }
                    } catch (error) {
                        addLog(`      â ï¸ Erreur relations ${relFile}: ${error.message}`, 'warning');
                    }
                }
                
                addLog(`    â RELATIONS MISE Ã JOUR`, 'success');
                
            } catch (error) {
                addLog(`    â Erreur mise Ã  jour relations: ${error.message}`, 'error');
            }
        }

        // Fonction pour formater les nombres avec des espaces
        function formatNumberWithSpaces(value) {
            try {
                const num = parseFloat(value);
                if (isNaN(num)) return '0';
                return Math.round(num).toLocaleString('fr-FR');
            } catch (error) {
                return '0';
            }
        }

        // Fonction pour crÃ©er le template email
        function createEmailTemplate(row, networkName) {
            try {
                // RÃ©cupÃ©rer le template personnalisÃ© de l'utilisateur
                const customTemplate = document.getElementById('emailTemplateEditor').value;
                
                // RÃ©cupÃ©rer les donnÃ©es de la ligne
                const city = row['Ville'] || 'Ville';
                const periode = row['PÃ©riode'] || 'pÃ©riode';
                const audience = row['Audience Cible'] || '0';
                const odv = row['ODV Total'] || '0';
                const reponse = row['RÃ©ponse'] || '0';
                const client = row['Client'] || networkName;
                
                // Calculer le numÃ©ro de semaine (utiliser la fonction existante)
                const weekNumber = getCurrentWeek();
                
                // Formater les donnÃ©es avec le mÃªme algorithme que PowerPoint
                const cityFormatted = city.toUpperCase();
                const audienceFormatted = formatNumberWithSpaces(audience);
                const odvFormatted = formatNumberWithSpaces(odv);
                const reponseFormatted = formatNumberWithSpaces(reponse);
                
                // Utiliser le mÃªme formatage de date que PowerPoint
                const periodeFormatted = formatDateForEmail(periode);
                
                // CrÃ©er l'objet de l'email
                const emailSubject = `Buster x ${client} - Vos rapports d'audience`;
                
                // Remplacer les variables dans le template personnalisÃ©
                let emailBody = customTemplate
                    .replace(/\{VILLE\}/g, cityFormatted)
                    .replace(/\{PERIODE\}/g, periodeFormatted)
                    .replace(/\{AUDIENCE\}/g, audienceFormatted)
                    .replace(/\{ODV\}/g, odvFormatted)
                    .replace(/\{REPONSE\}/g, reponseFormatted)
                    .replace(/\{WEEK\}/g, weekNumber);
                
                // Si le template est vide, utiliser le template par dÃ©faut
                if (!customTemplate.trim()) {
                    emailBody = `Bonjour,
Vous trouverez ci-joint le bilan complet de votre campagne menÃ©e sur les bus de ${cityFormatted} ${periodeFormatted}.
Durant cette pÃ©riode, vous avez touchÃ© une audience de ${audienceFormatted} personnes et votre campagne a gÃ©nÃ©rÃ© plus de ${odvFormatted} contacts.
Parcourez le document en piÃ¨ce jointe pour connaÃ®tre les indicateurs clÃ©s de votre campagne et le profil de votre audience.
Bien Ã  vous,

`;
                }
                
                 // CrÃ©er le contenu du fichier .txt
                 const txtContent = `Subject: ${emailSubject}

 ${emailBody}`;
                
                 return txtContent;
                
            } catch (error) {
                addLog(`â Erreur crÃ©ation template email: ${error.message}`, 'error');
                return `Bonjour,
Vous trouverez ci-joint le bilan complet de votre campagne.
Bien Ã  vous,

`;
            }
        }

        // Fonction pour formater les dates dans les emails (mÃªme algorithme que PowerPoint)
        function formatDateForEmail(dateStr) {
            if (!dateStr) return '';
            const match = dateStr.match(/du (\d{4}-\d{2}-\d{2}) au (\d{4}-\d{2}-\d{2})/i);
            if (!match) return dateStr;
            
            const [, startDate, endDate] = match;
            
            function formatSingleDate(date) {
                const [year, month, day] = date.split('-');
                const months = [
                    'janvier', 'fÃ©vrier', 'mars', 'avril', 'mai', 'juin',
                    'juillet', 'aoÃ»t', 'septembre', 'octobre', 'novembre', 'dÃ©cembre'
                ];
                return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
            }
            
            return `du ${formatSingleDate(startDate)} au ${formatSingleDate(endDate)}`;
        }

        // Fonction supprimÃ©e - plus d'Excel, uniquement XML

        // ANCIENNE FONCTION SUPPRIMÃE - REMPLACÃE PAR updateAgeChartDataDirect

        // Fonction supprimÃ©e - maintenant gÃ©rÃ©e par le traitement XML

        // Fonction supprimÃ©e - maintenant gÃ©rÃ©e par le traitement XML

        // ANCIENNES FONCTIONS SUPPRIMÃES - REMPLACÃES PAR LES FONCTIONS Direct

        // FONCTION SUPPRIMÃE - Plus utilisÃ©e avec l'approche Direct

        // Gestion du bouton Documentation
        document.getElementById('docBtn').addEventListener('click', function() {
            showDocumentation();
        });

        // Gestion des fichiers sÃ©lectionnÃ©s
        document.getElementById('excelFile').addEventListener('change', function(e) {
            const label = document.getElementById('excelLabel');
            const span = label.querySelector('span');
            if (e.target.files.length > 0) {
                span.textContent = e.target.files[0].name;
                label.classList.add('has-file');
            } else {
                span.textContent = 'SÃ©lectionner un fichier Excel (.xlsx, .xls)';
                label.classList.remove('has-file');
            }
        });

        document.getElementById('powerpointFile').addEventListener('change', function(e) {
            const label = document.getElementById('powerpointLabel');
            const span = label.querySelector('span');
            if (e.target.files.length > 0) {
                span.textContent = e.target.files[0].name;
                label.classList.add('has-file');
            } else {
                span.textContent = 'SÃ©lectionner un fichier PowerPoint (.pptx, .ppt)';
                label.classList.remove('has-file');
            }
        });

        // Fonctions pour l'Ã©cran de chargement PowerPoint
        function showPptLoadingScreen() {
            document.getElementById('pptLoadingScreen').classList.add('active');
            document.getElementById('loadingScreen').classList.remove('active');
            document.getElementById('formContainer').classList.add('hidden');
        }

        function hidePptLoadingScreen() {
            document.getElementById('pptLoadingScreen').classList.remove('active');
            document.getElementById('formContainer').classList.remove('hidden');
        }

        function updatePptProgress(current, total, status = '') {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const pptStatus = document.getElementById('pptStatus');
            
            const percentage = total > 0 ? (current / total) * 100 : 0;
            
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${current}/${total} fichiers traitÃ©s`;
            
            // Calculer l'estimation du temps restant avec produit en croix
            let timeEstimation = '';
            if (current > 0 && total > current && processingStartTime) {
                const elapsed = Date.now() - processingStartTime;
                const avgTimePerFile = elapsed / current;
                const remainingFiles = total - current;
                const estimatedRemainingMs = remainingFiles * avgTimePerFile;
                timeEstimation = `Temps restant estimÃ© : ${formatTime(estimatedRemainingMs)}`;
            } else if (current === total) {
                timeEstimation = 'Finalisation en cours...';
            } else {
                timeEstimation = 'Calcul en cours...';
            }
            
            if (pptStatus) {
                pptStatus.textContent = timeEstimation;
            }
            
            if (current > 0 && current < total) {
                progressBar.style.boxShadow = `0 0 15px rgba(162, 19, 123, 0.7)`;
                setTimeout(() => {
                    progressBar.style.boxShadow = `0 0 10px rgba(162, 19, 123, 0.5)`;
                }, 300);
            }
        }

        async function processFilesLocally(excelFile, powerpointFile, outputPrefix, emailDestination, emailTemplate = null, chartData = null) {
            try {
                addLog('DÃ©but du traitement local des fichiers', 'info');
                addLog(`Excel: ${excelFile.name}`, 'info');
                addLog(`PowerPoint: ${powerpointFile.name}`, 'info');
                addLog(`Email destination: ${emailDestination}`, 'info');
                
                showPptLoadingScreen();

                // 1. Lire le fichier Excel
                addLog('Lecture du fichier Excel...', 'info');
                const excelData = await readExcelFile(excelFile);
                
                // 2. Trouver la sheet "Performance mÃ©dia"
                const performanceSheet = excelData.Sheets['Performance mÃ©dia'];
                if (!performanceSheet) {
                    throw new Error('Sheet "Performance mÃ©dia" non trouvÃ©e dans le fichier Excel');
                }

                // 3. Convertir en JSON pour traitement
                const jsonData = XLSX.utils.sheet_to_json(performanceSheet);
                addLog('Sheet "Performance mÃ©dia" trouvÃ©e', 'success');
                addLog(`${jsonData.length} lignes trouvÃ©es dans Performance mÃ©dia`, 'info');

                // 4. Limiter Ã  3 lignes pour le debug
                const maxRows = Math.min(3, jsonData.length); // Limiter Ã  3 lignes pour le debug
                initializeTimeEstimation(maxRows);
                addLog(`ð§ DEBUG: Traitement limitÃ© Ã  ${maxRows} lignes (mode debug)`, 'warning');
                addLog(`Estimation du temps initialisÃ©e pour ${maxRows} fichiers`, 'info');
                
                if (jsonData.length > 0) {
                    const columns = Object.keys(jsonData[0]);
                    addLog(`Colonnes disponibles: ${columns.join(', ')}`, 'info');
                }

                // 4. Lire la sheet "Audience" pour les donnÃ©es dÃ©mographiques
                const audienceSheet = excelData.Sheets['Audience'];
                if (audienceSheet) {
                    addLog('â Sheet "Audience" trouvÃ©e', 'success');
                } else {
                    addLog('â ï¸ Sheet "Audience" non trouvÃ©e - les donnÃ©es dÃ©mographiques ne seront pas disponibles', 'warning');
                }


                // 5. Lire le fichier PowerPoint template
                addLog('ð Lecture du fichier PowerPoint template...', 'info');
                
                if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip n\'est pas chargÃ©. VÃ©rifiez la connexion internet.');
                }
                
                const templateArrayBuffer = await powerpointFile.arrayBuffer();
                addLog('Template PowerPoint lu', 'success');

                // 6. Traiter les 3 premiÃ¨res lignes (debug) - maxRows dÃ©jÃ  dÃ©fini plus haut
                addLog(`Traitement des ${maxRows} premiÃ¨res lignes (mode debug)...`, 'info');

                updatePptProgress(0, maxRows, 'PrÃ©paration des donnÃ©es...');

                const results = [];
                const allFiles = []; // Collecter tous les fichiers pour le ZIP final

                for (let i = 0; i < maxRows; i++) {
                    currentRow = i + 1; // Mettre Ã  jour le compteur global
                    const row = jsonData[i];
                    const networkName = row['rÃ©seau'] || row['RÃ©seau'] || `ligne_${i + 1}`;
                    addLog(`Traitement ligne ${i + 1}: ${networkName}`, 'info');
                    
                    updatePptProgress(i, maxRows);

                    try {
                        addLog(`  Traitement du template pour ligne ${i + 1}`, 'info');
                        
                        const zip = await JSZip.loadAsync(templateArrayBuffer);
                        
                        // Mapping des donnÃ©es avec formatage
                        const mapping = {
                            'ODV Total': 'ODV',
                            'GRP': 'GRP',
                            'RÃ©petition Cible': 'TIMES',
                            'ODV Cible': 'VIEWS',
                            'Couverture Cible': 'POP',
                            'PÃ©riode': 'DATE',
                            'Ville': 'CITY',
                            'Audience Cible': 'AUDIENCE',
                            'Client': 'CLIENT',
                            'WEEK': 'WEEK'
                        };

                        // Fonctions de formatage
                        function formatNumber(value, type) {
                            if (!value && value !== 0) return '';
                            const num = parseFloat(value);
                            if (isNaN(num)) return value;
                            
                            function addSpaces(number) {
                                return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
                            }
                            
                            switch(type) {
                                case 'ROUND_UP':
                                    return addSpaces(Math.ceil(num));
                                case 'ONE_DECIMAL':
                                    const decimal = num.toFixed(1);
                                    const [integer, fraction] = decimal.split('.');
                                    return addSpaces(integer) + '.' + fraction;
                                case 'TWO_DECIMALS_COMMA':
                                    const decimal2 = num.toFixed(2);
                                    const [integer2, fraction2] = decimal2.split('.');
                                    return addSpaces(integer2) + ',' + fraction2;
                                case 'PERCENTAGE':
                                    return addSpaces((num * 100).toFixed(0)) + '%';
                                default:
                                    return value;
                            }
                        }
                        
                        function formatDate(dateStr) {
                            if (!dateStr) return '';
                            const match = dateStr.match(/du (\d{4}-\d{2}-\d{2}) au (\d{4}-\d{2}-\d{2})/i);
                            if (!match) return dateStr;
                            
                            const [, startDate, endDate] = match;
                            
                            function formatSingleDate(date) {
                                const [year, month, day] = date.split('-');
                                const months = [
                                    'janvier', 'fÃ©vrier', 'mars', 'avril', 'mai', 'juin',
                                    'juillet', 'aoÃ»t', 'septembre', 'octobre', 'novembre', 'dÃ©cembre'
                                ];
                                return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
                            }
                            
                            return `du ${formatSingleDate(startDate)} au ${formatSingleDate(endDate)}`;
                        }

                        // PrÃ©parer les donnÃ©es pour le remplacement
                        const templateData = {};
                        let replacementsCount = 0;
                        
                        // Calculer le numÃ©ro de semaine actuelle
                        const weekNumber = getCurrentWeek();
                        templateData['WEEK'] = weekNumber;
                        addLog(`    ð NumÃ©ro de semaine calculÃ©: ${weekNumber}`, 'info');
                        
                        
                        for (const [excelColumn, templateKey] of Object.entries(mapping)) {
                            let value;
                            let formattedValue;
                            
                            // Traitement spÃ©cial pour WEEK (variable calculÃ©e)
                            if (templateKey === 'WEEK') {
                                value = weekNumber;
                                formattedValue = value.toString();
                                addLog(`    ð Variable WEEK calculÃ©e: ${value}`, 'info');
                            } else if (row[excelColumn] !== undefined && row[excelColumn] !== null) {
                                value = row[excelColumn];
                                
                                switch(templateKey) {
                                    case 'ODV': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    case 'GRP': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    case 'TIMES': formattedValue = formatNumber(value, 'TWO_DECIMALS_COMMA'); break;
                                    case 'VIEWS': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    case 'POP': formattedValue = formatNumber(value, 'PERCENTAGE'); break;
                                    case 'DATE': formattedValue = formatDate(value); break;
                                    case 'CITY': formattedValue = String(value).toUpperCase(); break;
                                    case 'AUDIENCE': formattedValue = formatNumber(value, 'ROUND_UP'); break;
                                    default: formattedValue = String(value);
                                }
                                
                                templateData[templateKey] = formattedValue;
                                addLog(`    ð ${excelColumn} â {${templateKey}} = ${formattedValue}`, 'info');
                                replacementsCount++;
                            } else if (templateKey !== 'WEEK') {
                                templateData[templateKey] = '';
                                addLog(`    â ï¸ Colonne "${excelColumn}" non trouvÃ©e pour {${templateKey}}`, 'warning');
                            }
                        }
                        
                        // S'assurer que WEEK est bien dans templateData
                        if (!templateData['WEEK']) {
                            templateData['WEEK'] = weekNumber;
                            addLog(`    ð WEEK ajoutÃ© au templateData: ${weekNumber}`, 'info');
                        }

                        // Utiliser les donnÃ©es saisies par l'utilisateur pour les graphiques
                        if (chartData) {
                            addLog(`  ð Utilisation des donnÃ©es saisies par l'utilisateur...`, 'info');
                            
                            // Utiliser les donnÃ©es des graphiques saisies par l'utilisateur
                            if (chartData['AGE']) {
                                templateData['AGE'] = chartData['AGE'];
                                addLog(`    â DonnÃ©es AGE utilisateur: "${templateData['AGE']}"`, 'success');
                            }
                            
                            if (chartData['SOCIO-PRO']) {
                                templateData['SOCIO-PRO'] = chartData['SOCIO-PRO'];
                                addLog(`    â DonnÃ©es CSP utilisateur: "${templateData['SOCIO-PRO']}"`, 'success');
                            }
                            
                            if (chartData['SEXE']) {
                                templateData['SEXE'] = chartData['SEXE'];
                                addLog(`    â DonnÃ©es SEXE utilisateur: "${templateData['SEXE']}"`, 'success');
                            }
                            
                            
                        } else if (audienceSheet) {
                            addLog(`  ð Lecture des donnÃ©es dÃ©mographiques depuis Excel...`, 'info');
                            
                            const currentPeriod = row['PÃ©riode'];
                            let audienceRowIndex = -1;
                            
                            for (let audienceRow = 2; audienceRow <= 100; audienceRow++) {
                                const audienceDateCell = audienceSheet[`A${audienceRow}`];
                                if (audienceDateCell && audienceDateCell.v === currentPeriod) {
                                    audienceRowIndex = audienceRow;
                                    addLog(`  â Ligne Audience trouvÃ©e: ${audienceRow}`, 'success');
                                    break;
                                }
                            }
                            
                            if (audienceRowIndex !== -1) {
                                // CORRECTION: DonnÃ©es AGE (colonnes C Ã  G) - VRAIES DONNÃES AGE
                                const ageColumns = ['C', 'D', 'E', 'F', 'G'];
                                const ageLabels = ['15-24 ans', '25-34 ans', '35-49 ans', '50-64 ans', '65 ans ou plus'];
                                const ageData = [];
                                
                                addLog(`    ð MAPPING DONNÃES AGE RÃELLES depuis Audience ligne ${audienceRowIndex}`, 'info');
                                addLog(`    ð Colonnes AGE utilisÃ©es: ${ageColumns.join(', ')}`, 'info');
                                for (let j = 0; j < ageColumns.length; j++) {
                                    const cellRef = `${ageColumns[j]}${audienceRowIndex}`;
                                    const cell = audienceSheet[cellRef];
                                    if (cell && cell.v !== undefined) {
                                        // VÃ©rifier si la valeur est dÃ©jÃ  en pourcentage ou en dÃ©cimal
                                        const cellValue = cell.v;
                                        const percentageValue = cellValue > 1 ? cellValue.toFixed(1) : (cellValue * 100).toFixed(1);
                                        ageData.push(`${ageLabels[j]}: ${percentageValue}%`);
                                        addLog(`      ð ${ageLabels[j]}: ${percentageValue}% (cellule ${cellRef})`, 'info');
                                    } else {
                                        addLog(`      â Cellule ${cellRef} vide ou invalide`, 'warning');
                                    }
                                }
                                templateData['AGE'] = ageData.join(', ');
                                addLog(`    â DonnÃ©es AGE finales: "${templateData['AGE']}"`, 'success');
                                
                                // CORRECTION: DonnÃ©es CSP (colonnes H Ã  P) - VRAIES DONNÃES CSP
                                const cspColumns = ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'];
                                const cspLabels = ['Agriculteurs', 'Artisans', 'Autres', 'Cadres', 'Ãtudiants', 'EmployÃ©s', 'Ouvriers', 'Professions intermÃ©diaires', 'RetraitÃ©s'];
                                const cspData = [];
                                
                                addLog(`    ð MAPPING DONNÃES CSP RÃELLES depuis Audience ligne ${audienceRowIndex}`, 'info');
                                addLog(`    ð Colonnes CSP utilisÃ©es: ${cspColumns.join(', ')}`, 'info');
                                for (let j = 0; j < cspColumns.length; j++) {
                                    const cellRef = `${cspColumns[j]}${audienceRowIndex}`;
                                    const cell = audienceSheet[cellRef];
                                    if (cell && cell.v !== undefined) {
                                        // VÃ©rifier si la valeur est dÃ©jÃ  en pourcentage ou en dÃ©cimal
                                        const cellValue = cell.v;
                                        const percentageValue = cellValue > 1 ? cellValue.toFixed(1) : (cellValue * 100).toFixed(1);
                                        cspData.push(`${cspLabels[j]}: ${percentageValue}%`);
                                        addLog(`      ð ${cspLabels[j]}: ${percentageValue}% (cellule ${cellRef})`, 'info');
                                    } else {
                                        addLog(`      â Cellule ${cellRef} vide ou invalide`, 'warning');
                                    }
                                }
                                templateData['SOCIO-PRO'] = cspData.join(', ');
                                addLog(`    â DonnÃ©es CSP finales: "${templateData['SOCIO-PRO']}"`, 'success');
                                
                                // DonnÃ©es SEXE (colonnes Q et R)
                                const menCell = audienceSheet[`Q${audienceRowIndex}`];
                                const womenCell = audienceSheet[`R${audienceRowIndex}`];
                                
                                addLog(`    ð MAPPING DONNÃES SEXE depuis Audience ligne ${audienceRowIndex}`, 'info');
                                if (menCell && womenCell && menCell.v !== undefined && womenCell.v !== undefined) {
                                    // VÃ©rifier si les valeurs sont dÃ©jÃ  en pourcentage ou en dÃ©cimal
                                    const menValue = menCell.v;
                                    const womenValue = womenCell.v;
                                    
                                    // Si la valeur est > 1, elle est dÃ©jÃ  en pourcentage, sinon c'est un dÃ©cimal
                                    const menPercentage = menValue > 1 ? menValue.toFixed(1) : (menValue * 100).toFixed(1);
                                    const womenPercentage = womenValue > 1 ? womenValue.toFixed(1) : (womenValue * 100).toFixed(1);
                                    templateData['SEXE'] = `Homme: ${menPercentage}%, Femme: ${womenPercentage}%`;
                                    templateData['MEN'] = `${menPercentage}%`;
                                    templateData['WOMEN'] = `${womenPercentage}%`;
                                    addLog(`      ð Homme: ${menPercentage}% (cellule Q${audienceRowIndex})`, 'info');
                                    addLog(`      ð Femme: ${womenPercentage}% (cellule R${audienceRowIndex})`, 'info');
                                    addLog(`    â DonnÃ©es SEXE finales: "${templateData['SEXE']}"`, 'success');
                                }
                            }
                        }

                        // Traiter les slides pour les remplacements de texte
                        const slideFiles = [];
                        zip.forEach((relativePath, file) => {
                            if (relativePath.includes('slides/slide') && relativePath.endsWith('.xml')) {
                                slideFiles.push(relativePath);
                            }
                        });
                        
                        addLog(`  ð ${slideFiles.length} slides trouvÃ©es`, 'info');
                        
                        // DEBUG: Afficher toutes les variables disponibles
                        addLog(`  ð DEBUG: Variables disponibles dans templateData:`, 'info');
                        for (const [key, value] of Object.entries(templateData)) {
                            addLog(`    ð ${key}: ${value}`, 'info');
                        }
                        
                        // Nouvelle logique simplifiÃ©e pour les pages de garde
                        const networkDataForCover = parseNetworkData(networkName);
                        const faceType = networkDataForCover.face ? networkDataForCover.face.toLowerCase() : '';
                        const cityName = networkDataForCover.ville ? networkDataForCover.ville.toLowerCase() : '';
                        const isFlancGauche = faceType.includes('gauche');
                        const isFlancDroit = faceType.includes('droit');
                        const isArriere = faceType.includes('arriÃ¨re') || faceType.includes('arriere');
                        const isBrest = cityName.includes('brest');
                        const isBrestFlancDroit = isBrest && isFlancDroit;
                        
                        addLog(`      ð Type de flanc dÃ©tectÃ©: ${networkDataForCover.face}`, 'info');
                        addLog(`      ðï¸ Ville dÃ©tectÃ©e: ${networkDataForCover.ville}`, 'info');
                        if (isBrestFlancDroit) {
                            addLog(`      â­ RÃ¨gle spÃ©ciale Brest + Flanc Droit activÃ©e`, 'info');
                        }
                        
                        // Traiter toutes les slides avec masquage au lieu de suppression
                        for (const slideFile of slideFiles) {
                            const content = await zip.file(slideFile).async('string');
                            let modifiedContent = content;
                            
                            // DÃ©terminer si cette slide doit Ãªtre masquÃ©e
                            let shouldHide = false;
                            let hideReason = '';
                            
                            // RÃ¨gles de masquage existantes (diapos 1 et 2)
                            if (slideFile.includes('slide1.xml') && isFlancGauche) {
                                shouldHide = true;
                                hideReason = 'Slide 1 masquÃ©e (Flanc Gauche)';
                            } else if (slideFile.includes('slide2.xml') && !isFlancGauche) {
                                shouldHide = true;
                                hideReason = 'Slide 2 masquÃ©e (Flanc Droit/ArriÃ¨re)';
                            }
                            
                            // Nouvelles rÃ¨gles de masquage
                            if (slideFile.includes('slide5.xml')) {
                                if (isBrestFlancDroit) {
                                    // RÃ¨gle spÃ©ciale Brest : masquer slide 5 si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 5 masquÃ©e (Brest + Flanc Droit)';
                                } else if (isFlancDroit || isArriere) {
                                    shouldHide = true;
                                    hideReason = 'Slide 5 masquÃ©e (Flanc Droit/ArriÃ¨re)';
                                }
                            } else if (slideFile.includes('slide6.xml')) {
                                if (isBrestFlancDroit) {
                                    // RÃ¨gle spÃ©ciale Brest : masquer slide 6 si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 6 masquÃ©e (Brest + Flanc Droit)';
                                } else if (isFlancGauche || isFlancDroit) {
                                    shouldHide = true;
                                    hideReason = 'Slide 6 masquÃ©e (Flanc Gauche/Droit)';
                                }
                            } else if (slideFile.includes('slide7.xml')) {
                                if (isBrestFlancDroit) {
                                    // RÃ¨gle spÃ©ciale Brest : masquer slide 7 si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 7 masquÃ©e (Brest + Flanc Droit)';
                                } else if (isFlancGauche || isArriere) {
                                    shouldHide = true;
                                    hideReason = 'Slide 7 masquÃ©e (Flanc Gauche/ArriÃ¨re)';
                                }
                            } else if (slideFile.includes('slide8.xml')) {
                                if (!isBrestFlancDroit) {
                                    // RÃ¨gle spÃ©ciale Brest : masquer slide 8 sauf si Brest + flanc droit
                                    shouldHide = true;
                                    hideReason = 'Slide 8 masquÃ©e (Non Brest ou Non Flanc Droit)';
                                } else {
                                    addLog(`      â Slide 8 affichÃ©e (Brest + Flanc Droit)`, 'success');
                                }
                            }
                            
                            if (shouldHide) {
                                addLog(`      ðï¸ ${hideReason}`, 'info');
                            }
                            
                            // DÃ©sactiver visuellement la slide dans l'Ã©diteur
                            if (shouldHide) {
                                // MÃ©thode 1: Ajouter show="0" pour masquer la slide
                                modifiedContent = modifiedContent.replace(
                                    /<p:sld[^>]*>/g, 
                                    (match) => {
                                        if (!match.includes('show=')) {
                                            return match.replace('>', ' show="0">');
                                        }
                                        return match;
                                    }
                                );
                                
                                // MÃ©thode 2: Ajouter hidden="1" pour la dÃ©sactiver complÃ¨tement
                                modifiedContent = modifiedContent.replace(
                                    /<p:sld[^>]*>/g,
                                    (match) => {
                                        if (!match.includes('hidden=')) {
                                            return match.replace('>', ' hidden="1">');
                                        }
                                        return match;
                                    }
                                );
                                
                                // MÃ©thode 3: Modifier le type de slide pour la rendre invisible
                                modifiedContent = modifiedContent.replace(
                                    /<p:sldId[^>]*>/g,
                                    (match) => {
                                        if (!match.includes('show=')) {
                                            return match.replace('>', ' show="0" hidden="1">');
                                        }
                                        return match;
                                    }
                                );
                                
                                addLog(`      ð§ Slide dÃ©sactivÃ©e visuellement dans ${slideFile}`, 'info');
                                addLog(`      ð§ Attributs ajoutÃ©s: show="0" hidden="1"`, 'info');
                            }
                            
                            // Traiter les variables pour toutes les slides
                            for (const [templateKey, value] of Object.entries(templateData)) {
                                const placeholder = `{${templateKey}}`;
                                if (modifiedContent.includes(placeholder)) {
                                    modifiedContent = modifiedContent.replace(new RegExp(placeholder, 'g'), value);
                                    addLog(`      ð RemplacÃ© ${placeholder} par ${value}`, 'info');
                                }
                            }
                            
                            zip.file(slideFile, modifiedContent);
                            addLog(`      â Slide traitÃ©e: ${slideFile}`, 'success');
                        }
                        
                        // DÃ©sactiver les slides dans presentation.xml pour qu'elles n'apparaissent pas dans l'Ã©diteur
                        try {
                            const presentationContent = await zip.file('ppt/presentation.xml').async('string');
                            let modifiedPresentation = presentationContent;
                            
                            // DÃ©sactiver slide 1 si flanc gauche
                            if (isFlancGauche) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId1"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 1 dÃ©sactivÃ©e dans presentation.xml (Flanc Gauche)`, 'info');
                            }
                            
                            // DÃ©sactiver slide 2 si flanc droit ou arriÃ¨re
                            if (!isFlancGauche) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId2"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 2 dÃ©sactivÃ©e dans presentation.xml (Flanc Droit/ArriÃ¨re)`, 'info');
                            }
                            
                            // DÃ©sactiver slide 5 selon les rÃ¨gles
                            if (isBrestFlancDroit) {
                                // RÃ¨gle spÃ©ciale Brest : dÃ©sactiver slide 5 si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId5"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 5 dÃ©sactivÃ©e dans presentation.xml (Brest + Flanc Droit)`, 'info');
                            } else if (isFlancDroit || isArriere) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId5"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 5 dÃ©sactivÃ©e dans presentation.xml (Flanc Droit/ArriÃ¨re)`, 'info');
                            }
                            
                            // DÃ©sactiver slide 6 selon les rÃ¨gles
                            if (isBrestFlancDroit) {
                                // RÃ¨gle spÃ©ciale Brest : dÃ©sactiver slide 6 si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId6"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 6 dÃ©sactivÃ©e dans presentation.xml (Brest + Flanc Droit)`, 'info');
                            } else if (isFlancGauche || isFlancDroit) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId6"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 6 dÃ©sactivÃ©e dans presentation.xml (Flanc Gauche/Droit)`, 'info');
                            }
                            
                            // DÃ©sactiver slide 7 selon les rÃ¨gles
                            if (isBrestFlancDroit) {
                                // RÃ¨gle spÃ©ciale Brest : dÃ©sactiver slide 7 si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId7"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 7 dÃ©sactivÃ©e dans presentation.xml (Brest + Flanc Droit)`, 'info');
                            } else if (isFlancGauche || isArriere) {
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId7"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 7 dÃ©sactivÃ©e dans presentation.xml (Flanc Gauche/ArriÃ¨re)`, 'info');
                            }
                            
                            // DÃ©sactiver slide 8 selon la rÃ¨gle spÃ©ciale Brest
                            if (!isBrestFlancDroit) {
                                // Masquer slide 8 sauf si Brest + flanc droit
                                modifiedPresentation = modifiedPresentation.replace(
                                    /(<p:sldId id="\d+" r:id="rId8"[^>]*>)/g,
                                    '$1<p:extLst><p:ext uri="{FF2C5E14-C905-4F95-9C57-5AF2B2EE5661}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="00000000-0000-0000-0000-000000000000"/></p:ext></p:extLst>'
                                );
                                addLog(`      ð§ Slide 8 dÃ©sactivÃ©e dans presentation.xml (Non Brest ou Non Flanc Droit)`, 'info');
                            } else {
                                addLog(`      â Slide 8 activÃ©e dans presentation.xml (Brest + Flanc Droit)`, 'success');
                            }
                            
                            if (modifiedPresentation !== presentationContent) {
                                zip.file('ppt/presentation.xml', modifiedPresentation);
                                addLog(`      â presentation.xml modifiÃ© pour dÃ©sactiver les slides`, 'success');
                            }
                        } catch (error) {
                            addLog(`      â ï¸ Erreur modification presentation.xml: ${error.message}`, 'warning');
                        }

                        // Traiter les graphiques Excel embarquÃ©s
                        const chartsProcessed = await processEmbeddedCharts(zip, templateData, row, excelData);
                        addLog(`  ð ${chartsProcessed} graphiques traitÃ©s`, 'info');
                        
                        // NOUVELLE APPROCHE: Forcer la mise Ã  jour de tous les graphiques
                        if (chartsProcessed > 0) {
                            addLog(`  ð FORCE LA MISE Ã JOUR DE TOUS LES GRAPHIQUES...`, 'info');
                            await forceAllChartsRefresh(zip);
                        }
                        
                        // GÃ©nÃ©rer le fichier PowerPoint
                        const blob = await zip.generateAsync({
                            type: "blob",
                            compression: "STORE", // Pas de compression pour Ã©viter la corruption
                            compressionOptions: { level: 0 }
                        });

                        // Validation du fichier gÃ©nÃ©rÃ©
                        if (!blob || blob.size === 0) {
                            throw new Error(`Fichier PowerPoint vide gÃ©nÃ©rÃ© pour ${networkName}`);
                        }
                        
                        addLog(`  â Fichier PowerPoint gÃ©nÃ©rÃ©: ${(blob.size / 1024 / 1024).toFixed(2)} MB`, 'success');

                        // GÃ©nÃ©rer le nom de fichier selon la nouvelle nomenclature
                        // Format: "Buster x [ville] - [flanc] - [ville] - S[numero_semaine].pptx"
                        const networkData = parseNetworkData(networkName);
                        const city = networkData.ville || row['Ville'] || 'Inconnue';
                        const flanc = networkData.face || 'Inconnu';
                        const currentWeek = getCurrentWeek();
                        const fileName = `Buster x ${city} - ${flanc} - ${city} - S${currentWeek}.pptx`;
                        
                        addLog(`  ð DonnÃ©es rÃ©seau parsÃ©es: ${JSON.stringify(networkData)}`, 'info');
                        
                        // CrÃ©er le chemin de fichier avec la hiÃ©rarchie
                        const filePath = createFileHierarchy(networkData, fileName);
                        
                        // Collecter le fichier pour le ZIP avec la hiÃ©rarchie
                        allFiles.push({
                            name: filePath,
                            blob: blob,
                            type: 'pptx',
                            networkData: networkData
                        });
                        
                        
                         // CrÃ©er le fichier template email avec extension .txt
                         const emailTemplate = createEmailTemplate(row, networkName);
                         const msgFileName = `Template email - ${fileName.replace('.pptx', '.txt')}`;
                         const msgFilePath = createFileHierarchy(networkData, msgFileName);
                         const msgBlob = new Blob([emailTemplate], { type: 'text/plain;charset=utf-8' });
                        
                         // Collecter le fichier email pour le ZIP final avec la hiÃ©rarchie
                         allFiles.push({
                             name: msgFilePath,
                             blob: msgBlob,
                             type: 'txt',
                             networkData: networkData
                         });
                        
                        addLog(`  ð§ Template email gÃ©nÃ©rÃ©: ${msgFileName}`, 'info');
                        
                        results.push({
                            fileName: fileName,
                            network: networkName,
                            replacements: replacementsCount,
                            charts: chartsProcessed,
                            row: i + 1
                        });

                        addLog(`  â Fichier crÃ©Ã©: ${fileName}`, 'success');
                        addLog(`  â Template email crÃ©Ã©: ${msgFileName}`, 'success');
                        updatePptProgress(i + 1, maxRows);
                        
                    } catch (error) {
                        addLog(`  â Erreur ligne ${i + 1}: ${error.message}`, 'error');
                        updatePptProgress(i + 1, maxRows);
                    }
                }
                
                updatePptProgress(maxRows, maxRows);

                // CrÃ©er le ZIP final avec tous les fichiers
                if (allFiles.length > 0) {
                    addLog(`ð¦ CrÃ©ation du dossier ZIP avec ${allFiles.length} fichiers...`, 'info');
                    
                    try {
                        // CrÃ©er un nouveau ZIP pour contenir tous les fichiers
                        const finalZip = new JSZip();
                        
                        // Ajouter tous les fichiers au ZIP
                        for (const file of allFiles) {
                            finalZip.file(file.name, file.blob);
                        }
                        
                        // GÃ©nÃ©rer le ZIP final
                        const finalZipBlob = await finalZip.generateAsync({
                            type: "blob",
                            compression: "STORE", // Pas de compression pour Ã©viter la corruption
                            compressionOptions: { level: 0 }
                        });
                        
                        // Validation du ZIP final
                        if (!finalZipBlob || finalZipBlob.size === 0) {
                            throw new Error('ZIP final vide gÃ©nÃ©rÃ©');
                        }
                        
                        addLog(`â ZIP final gÃ©nÃ©rÃ©: ${(finalZipBlob.size / 1024 / 1024).toFixed(2)} MB`, 'success');
                        
                        // Envoyer le ZIP vers le webhook Taskalys avec le bon nom
                        const currentYear = new Date().getFullYear();
                        const zipFileName = `${currentYear} - rapports d'audience.zip`;
                        addLog(`ð¦ Envoi du dossier ZIP vers Taskalys: ${zipFileName}`, 'success');
                        
                        try {
                            // CrÃ©er FormData pour l'envoi
                            const formData = new FormData();
                            formData.append('file', finalZipBlob, zipFileName);
                            formData.append('timestamp', new Date().toISOString());
                            formData.append('totalFiles', allFiles.length.toString());
                            formData.append('email', emailDestination);
                            addLog(`ð§ Email de destination inclus: ${emailDestination}`, 'info');
                            
                            // Envoyer vers le webhook
                            const response = await fetch('https://host.taskalys.app/webhook/buster', {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const result = await response.text();
                                addLog(`â ZIP envoyÃ© avec succÃ¨s vers Taskalys`, 'success');
                                addLog(`ð RÃ©ponse du serveur: ${result}`, 'info');
                            } else {
                                addLog(`â Erreur envoi ZIP: ${response.status} ${response.statusText}`, 'error');
                            }
                            
                        } catch (error) {
                            addLog(`â Erreur envoi vers Taskalys: ${error.message}`, 'error');
                            
                            // Solution de secours : tÃ©lÃ©chargement local pour test
                            addLog(`ð TÃ©lÃ©chargement local comme solution de secours...`, 'warning');
                            
                            try {
                                const downloadLink = document.createElement('a');
                                downloadLink.href = URL.createObjectURL(finalZipBlob);
                                downloadLink.download = zipFileName;
                                downloadLink.click();
                                addLog(`â Fichier ZIP tÃ©lÃ©chargÃ© localement: ${zipFileName}`, 'success');
                                addLog(`ð¡ Vous pouvez maintenant tester l'ouverture des fichiers PowerPoint`, 'info');
                            } catch (downloadError) {
                                addLog(`â Erreur tÃ©lÃ©chargement local: ${downloadError.message}`, 'error');
                                throw new Error(`Ãchec complet: API + TÃ©lÃ©chargement local`);
                            }
                        }
                        
                        addLog(`â ${allFiles.length} fichiers envoyÃ©s dans le dossier ZIP vers Taskalys`, 'success');
                        
                        // Afficher des informations sur l'envoi vers Taskalys
                        addLog(`ð¡ Les fichiers ont Ã©tÃ© envoyÃ©s vers le serveur Taskalys`, 'info');
                        addLog(`ð§ Consultez vos emails pour recevoir les rapports d'audience`, 'success');
                        addLog(`ð Webhook: https://host.taskalys.app/webhook-test/buster`, 'info');
                        
                        // ArrÃªter l'estimation du temps
                        stopTimeEstimation();
                        
                    } catch (error) {
                        addLog(`â Erreur crÃ©ation ZIP: ${error.message}`, 'error');
                    }
                }

                setTimeout(() => {
                    hidePptLoadingScreen();
                }, 2000);

                return {
                    success: true,
                    processed: results.length,
                    results: results,
                    totalRows: jsonData.length,
                    totalFiles: allFiles.length
                };

            } catch (error) {
                addLog(`â Erreur lors du traitement: ${error.message}`, 'error');
                stopTimeEstimation(); // ArrÃªter l'estimation du temps en cas d'erreur
                hidePptLoadingScreen();
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Fonction pour lire un fichier Excel
        function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        resolve(workbook);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Erreur lors de la lecture du fichier Excel'));
                reader.readAsArrayBuffer(file);
            });
        }

        // Variables pour l'estimation du temps
        let processingStartTime = null;
        let totalRowsToProcess = 0;
        let currentRow = 0;
        let estimatedTimePerFile = 15000; // 15 secondes par fichier en moyenne
        let timeEstimationInterval = null;

        // Fonctions pour l'estimation du temps
        function initializeTimeEstimation(totalRows) {
            totalRowsToProcess = totalRows;
            processingStartTime = Date.now();
            
            // Mettre Ã  jour l'affichage initial
            updateTimeEstimation(0);
            
            // DÃ©marrer l'intervalle de mise Ã  jour
            timeEstimationInterval = setInterval(() => {
                updateTimeEstimation(currentRow);
            }, 1000);
        }

        function updateTimeEstimation(processedRows) {
            const timeRemainingValue = document.getElementById('timeRemainingValue');
            const processedCount = document.getElementById('processedCount');
            const totalCount = document.getElementById('totalCount');
            
            if (timeRemainingValue && processedCount && totalCount) {
                processedCount.textContent = processedRows;
                totalCount.textContent = totalRowsToProcess;
                
                if (processedRows === 0) {
                    timeRemainingValue.textContent = 'Calcul en cours...';
                } else {
                    const elapsed = Date.now() - processingStartTime;
                    const avgTimePerFile = elapsed / processedRows;
                    const remainingFiles = totalRowsToProcess - processedRows;
                    const estimatedRemainingMs = remainingFiles * avgTimePerFile;
                    
                    timeRemainingValue.textContent = formatTime(estimatedRemainingMs);
                }
            }
        }

        function formatTime(milliseconds) {
            const seconds = Math.round(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            if (minutes > 0) {
                return `${minutes}m ${remainingSeconds}s`;
            } else {
                return `${remainingSeconds}s`;
            }
        }

        function stopTimeEstimation() {
            if (timeEstimationInterval) {
                clearInterval(timeEstimationInterval);
                timeEstimationInterval = null;
            }
        }

        // Fonction pour ajouter des logs
        function addLog(message, type = 'info') {
            const logsContent = document.getElementById('logsContent');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const time = new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-message">${message}</span>
            `;
            
            logsContent.appendChild(logEntry);
            logsContent.scrollTop = logsContent.scrollHeight;
        }




        // Fonction pour obtenir le nombre de valeurs attendues par type de graphique
        function getExpectedValuesCount(chartType) {
            switch (chartType) {
                case 'AGE':
                    return 5; // 15-24, 25-34, 35-49, 50-64, 65+
                case 'CSP':
                    return 0; // Variable selon les donnÃ©es
                default:
                    return 0; // Inconnu
            }
        }

        // Fonction de validation des donnÃ©es des graphiques
        function validateChartData(ageData, cspData, provData) {
            try {
                // Validation des donnÃ©es AGE
                if (ageData && ageData.trim()) {
                    const agePattern = /(\d+-\d+ ans(?:\s+ou\s+plus)?):\s*(\d+(?:\.\d+)?)%/g;
                    const ageMatches = [...ageData.matchAll(agePattern)];
                    if (ageMatches.length === 0) {
                        return { isValid: false, error: 'Format des donnÃ©es AGE invalide. Utilisez: "15-24 ans: 25%, 25-34 ans: 30%"' };
                    }
                    
                    // VÃ©rifier que la somme des pourcentages est proche de 100%
                    const totalAge = ageMatches.reduce((sum, match) => sum + parseFloat(match[2]), 0);
                    if (Math.abs(totalAge - 100) > 5) {
                        return { isValid: false, error: `La somme des pourcentages AGE doit Ãªtre proche de 100% (actuellement: ${totalAge.toFixed(1)}%)` };
                    }
                }
                
                // Validation des donnÃ©es CSP
                if (cspData && cspData.trim()) {
                    const cspPattern = /([^:]+):\s*(\d+(?:\.\d+)?)%/g;
                    const cspMatches = [...cspData.matchAll(cspPattern)];
                    if (cspMatches.length === 0) {
                        return { isValid: false, error: 'Format des donnÃ©es CSP invalide. Utilisez: "Cadres: 40%, EmployÃ©s: 35%"' };
                    }
                    
                    const totalCsp = cspMatches.reduce((sum, match) => sum + parseFloat(match[2]), 0);
                    if (Math.abs(totalCsp - 100) > 5) {
                        return { isValid: false, error: `La somme des pourcentages CSP doit Ãªtre proche de 100% (actuellement: ${totalCsp.toFixed(1)}%)` };
                    }
                }
                
                
                
                return { isValid: true };
            } catch (error) {
                return { isValid: false, error: `Erreur de validation: ${error.message}` };
            }
        }

        // Gestion de la soumission du formulaire
        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const excelFile = document.getElementById('excelFile').files[0];
            const powerpointFile = document.getElementById('powerpointFile').files[0];
            const emailDestination = document.getElementById('emailInput').value;
            const outputPrefix = 'rapport_audience';
            
            // RÃ©cupÃ©rer les donnÃ©es des graphiques saisies par l'utilisateur
            const ageData = document.getElementById('ageData').value;
            const cspData = document.getElementById('cspData').value;
            const provData = document.getElementById('provData').value;

            addLog(`Validation: Excel=${excelFile ? 'OK' : 'MANQUANT'}, PowerPoint=${powerpointFile ? 'OK' : 'MANQUANT'}, Email=${emailDestination ? 'OK' : 'MANQUANT'}`, 'info');
            
            // Validation des donnÃ©es des graphiques
            const chartDataValidation = validateChartData(ageData, cspData, provData);
            if (!chartDataValidation.isValid) {
                addLog(`Erreur validation donnÃ©es graphiques: ${chartDataValidation.error}`, 'error');
                return;
            }
            
            if (!excelFile) {
                addLog('Veuillez sÃ©lectionner un fichier Excel', 'error');
                return;
            }
            
            if (!powerpointFile) {
                addLog('Veuillez sÃ©lectionner un fichier PowerPoint', 'error');
                return;
            }

            if (!emailDestination) {
                addLog('Veuillez saisir l\'email de destination', 'error');
                return;
            }


            document.getElementById('formContainer').classList.add('hidden');
            document.getElementById('loadingScreen').classList.add('active');

            const dots = document.querySelector('.dots');
            let dotCount = 0;
            const dotInterval = setInterval(() => {
                dotCount = (dotCount + 1) % 4;
                dots.textContent = '.'.repeat(dotCount);
            }, 500);

            try {
                addLog('DÃ©marrage du traitement local...', 'info');
                const result = await processFilesLocally(excelFile, powerpointFile, outputPrefix, emailDestination, null, {
                    'AGE': ageData,
                    'SOCIO-PRO': cspData
                });
                
                clearInterval(dotInterval);
                
                if (result.success) {
                    addLog('Traitement rÃ©ussi!', 'success');
                    showLocalProcessingResult(result);
                } else {
                    addLog(`Ãchec du traitement: ${result.error}`, 'error');
                    showErrorResult(result.error);
                }
            } catch (error) {
                clearInterval(dotInterval);
                stopTimeEstimation(); // ArrÃªter l'estimation du temps en cas d'erreur
                addLog(`Erreur: ${error.message}`, 'error');
                showErrorResult(error.message);
            }
            
            document.getElementById('uploadForm').reset();
            document.getElementById('excelLabel').querySelector('span').textContent = 'SÃ©lectionner un fichier Excel (.xlsx, .xls)';
            document.getElementById('excelLabel').classList.remove('has-file');
            document.getElementById('powerpointLabel').querySelector('span').textContent = 'SÃ©lectionner un fichier PowerPoint (.pptx, .ppt)';
            document.getElementById('powerpointLabel').classList.remove('has-file');
            
            document.getElementById('formContainer').classList.remove('hidden');
            document.getElementById('loadingScreen').classList.remove('active');
        });

        // Fonction pour basculer l'affichage de la console
        function toggleConsole() {
            const console = document.getElementById('logsContainer');
            const button = document.getElementById('toggleConsoleBtn');
            
            if (console.style.display === 'none' || console.style.display === '') {
                console.style.display = 'block';
                button.textContent = 'Masquer Console';
            } else {
                console.style.display = 'none';
                button.textContent = 'Console';
            }
        }

        // Ajouter l'Ã©vÃ©nement au bouton console
        document.addEventListener('DOMContentLoaded', function() {
            const toggleBtn = document.getElementById('toggleConsoleBtn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleConsole);
            }
        });

        // Fonction pour afficher la documentation (version professionnelle)
        function showDocumentation() {
            const doc = `
DOCUMENTATION - GÃNÃRATEUR DE RAPPORTS D'AUDIENCE

FONCTIONNALITÃS
â¢ GÃ©nÃ©ration automatique de rapports PowerPoint
â¢ Traitement des donnÃ©es Excel (Performance mÃ©dia, Audience, Provenance)
â¢ Gestion des pages de garde selon le type de flanc
â¢ Masquage automatique des diapositives selon le type de flanc
â¢ Envoi automatique par email via API Taskalys

FICHIERS REQUIS
â¢ Fichier Excel avec feuilles : "Performance mÃ©dia", "Audience", "Provenance"
â¢ Template PowerPoint avec variables {VILLE}, {PERIODE}, {AUDIENCE}, etc.

VARIABLES DISPONIBLES
â¢ {VILLE} - Nom de la ville (majuscules)
â¢ {PERIODE} - PÃ©riode formatÃ©e (ex: "du 1 janvier 2024 au 7 janvier 2024")
â¢ {AUDIENCE} - Audience cible formatÃ©e
â¢ {ODV} - Nombre d'ODV formatÃ©
â¢ {NB_SEMAINE} - NumÃ©ro de semaine (1-52)

 EMAIL
 â¢ Template personnalisable avec variables
 â¢ Fichiers .txt avec objet "Buster x [client] - Vos rapports d'audience"
 â¢ Envoi automatique via API Taskalys
 â¢ Fichiers organisÃ©s par hiÃ©rarchie (AnnÃ©e/Semaine/Ville/Face/Version)

MASQUAGE DES DIAPOSITIVES
â¢ Flanc Gauche : masque les diapositives 1, 6 et 7
â¢ Flanc Droit : masque les diapositives 2, 5 et 6
â¢ ArriÃ¨re : masque les diapositives 2, 5 et 7
â¢ RÃ¨gle spÃ©ciale Brest + Flanc Droit : affiche la diapositive 8 et masque les diapositives 5, 6 et 7
â¢ Diapositive 8 : masquÃ©e dans tous les autres cas
â¢ Les diapositives masquÃ©es ne sont pas visibles dans l'Ã©diteur PowerPoint

TRAITEMENT
â¢ LimitÃ© Ã  3 lignes en mode debug
â¢ Estimation du temps en temps rÃ©el
â¢ Masquage des slides selon le type de flanc
â¢ GÃ©nÃ©ration de ZIP avec hiÃ©rarchie de dossiers
            `;
            
            alert(doc);
            return;
        }

        // Gestionnaire d'Ã©vÃ©nements pour les clics sur les boutons
        document.getElementById('submitBtn').addEventListener('click', function(e) {
            e.preventDefault();
            
            const excelFile = document.getElementById('excelFile').files[0];
            const powerpointFile = document.getElementById('powerpointFile').files[0];
            const emailDestination = document.getElementById('emailInput').value;
            const emailTemplate = document.getElementById('emailTemplateEditor').value;
            
            if (!excelFile || !powerpointFile) {
                showErrorResult('Veuillez sÃ©lectionner un fichier Excel et un template PowerPoint.');
                return;
            }
            
            if (!emailDestination.trim()) {
                showErrorResult('Veuillez saisir une adresse email de destination.');
                return;
            }
            
            // DÃ©marrer le traitement
            processFilesLocally(excelFile, powerpointFile, 'rapport_audience', emailDestination, emailTemplate);
        });

        // Gestion de l'interface de logs
        document.getElementById('clearLogsBtn').addEventListener('click', function() {
            const logsContent = document.getElementById('logsContent');
            logsContent.innerHTML = `
                <div class="log-entry info">
                    <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                    <span class="log-message">Logs effacÃ©s - Interface prÃªte</span>
                </div>
            `;
        });

        // Toggle pour rÃ©duire/agrandir les logs
        document.querySelector('.logs-header').addEventListener('click', function() {
            const logsContainer = document.getElementById('logsContainer');
            logsContainer.classList.toggle('collapsed');
        });

        // Animation des points de chargement
        const dots = document.querySelector('.dots');
        let dotCount = 0;
        setInterval(() => {
            if (document.getElementById('loadingScreen').classList.contains('active')) {
                dotCount = (dotCount + 1) % 4;
                dots.textContent = '.'.repeat(dotCount);
            }
        }, 500);
    </script>
</body>
</html>
